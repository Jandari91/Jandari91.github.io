<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>잔다리 블로그</title>
    <description>it develope 개발.</description>
    <link>https://jandari91.github.io/</link>
    <atom:link href="https://jandari91.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 08 Jan 2023 11:40:11 +0900</pubDate>
    <lastBuildDate>Sun, 08 Jan 2023 11:40:11 +0900</lastBuildDate>
    <generator>Jekyll v4.3.1</generator>
    
      <item>
        <title>Rust 단일 파일 실행하기</title>
        <description>
</description>
        <pubDate>Fri, 06 Jan 2023 22:00:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/Rust_Execute/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/Rust_Execute/</guid>
        
        <category>Rust</category>
        
        <category>Linux</category>
        
        <category>VSCode</category>
        
        <category>설치</category>
        
        
        <category>Rust</category>
        
        <category>설치</category>
        
      </item>
    
      <item>
        <title>Rust 설치 및 VS Code 셋팅(Linux, Debian)</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;최근 Rust에 관심이 생겨 Rust를 공부하고 있습니다.&lt;/p&gt;

&lt;p&gt;제가 집에서 사용하는 PC는 Mint Linux로 Debian 계열의 리눅스를 사용하고 있습니다.&lt;/p&gt;

&lt;p&gt;Linux에 Rust를 설치하는 방법과 VS Code에서 Rust를 사용하는 방법에 대해 정리하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;rust-설치&quot;&gt;Rust 설치&lt;/h2&gt;

&lt;p&gt;리눅스에서 Rust를 설치하는 방법은 3가지가 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;rustup 사용 : 공식 사이트에서 가장 추천하는 방법 입니다.&lt;/li&gt;
  &lt;li&gt;패키지 매니저 사용 : 편리하지만 오래 된 버전의 Rust가 설치 됩니다.&lt;/li&gt;
  &lt;li&gt;직접 소스코드 빌드 : 특이한 경우가 아니라면 비추입니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;저는 이 중 가장 추천하는 rustup을 사용하여 설치하겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;rustup으로-설치하기&quot;&gt;Rustup으로 설치하기&lt;/h3&gt;

&lt;p&gt;먼저 터미널을 실행 시킵니다.(Ctrl + Alt + T)&lt;/p&gt;

&lt;p&gt;아래 명령어를 사용합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;bak:~$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

info: downloading installer

Welcome to Rust!

This will download and install the official compiler for the Rust
programming language, and its package manager, Cargo.

Rustup metadata and toolchains will be installed into the Rustup
home directory, located at:

  /home/bak/.rustup

This can be modified with the RUSTUP_HOME environment variable.

The Cargo home directory is located at:

  /home/bak/.cargo

This can be modified with the CARGO_HOME environment variable.

The cargo, rustc, rustup and other commands will be added to
Cargo's bin directory, located at:

  /home/bak/.cargo/bin

This path will then be added to your PATH environment variable by
modifying the profile files located at:

  /home/bak/.profile
  /home/bak/.bashrc

You can uninstall at any time with rustup self uninstall and
these changes will be reverted.

Current installation options:


   default host triple: x86_64-unknown-linux-gnu
     default toolchain: stable (default)
               profile: default
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
1
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같은 글씨가 출력되면 1 을 입력한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;info: profile set to 'default'
info: default host triple is x86_64-unknown-linux-gnu
info: syncing channel updates for 'stable-x86_64-unknown-linux-gnu'
info: latest update on 2022-12-15, rust version 1.66.0 (69f9c33d7 2022-12-12)
info: downloading component 'cargo'
info: downloading component 'clippy'
info: downloading component 'rust-docs'
info: downloading component 'rust-std'
info: downloading component 'rustc'
 68.0 MiB /  68.0 MiB (100 %)  55.3 MiB/s in  1s ETA:  0s
info: downloading component 'rustfmt'|-|-|
info: installing component 'rust-std'
 29.7 MiB /  29.7 MiB (100 %)  14.0 MiB/s in  2s ETA:  0s
info: installing component 'rustc'
 68.0 MiB /  68.0 MiB (100 %)  15.5 MiB/s in  4s ETA:  0s
info: installing component 'rustfmt'
info: default toolchain set to 'stable-x86_64-unknown-linux-gnu'

  stable-x86_64-unknown-linux-gnu installed - rustc 1.66.0 (69f9c33d7 2022-12-12)


Rust is installed now. Great!

To get started you may need to restart your current shell.
This would reload your PATH environment variable to include
Cargo's bin directory ($HOME/.cargo/bin).

To configure your current shell, run:
source &quot;$HOME/.cargo/env&quot;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 cargo나 rustc 등등 필요한 패키지들이 설치 된다.&lt;/p&gt;

&lt;p&gt;위 이야기를 보면 최근 shell을 다시 시작하라고 나온다. 그래서 설치한 터미널에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rustc&lt;/code&gt;를 입력해도 찾을수 없다고 나온다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;bak:~$ rustc --version
명령어 'rustc' 을(를) 찾을 수 없습니다. 그러나 다음을 통해 설치할 수 있습니다:
sudo apt install rustc
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;새로운 터미널을 열어 다시 입력하면 아래와 같이 정상적으로 출력되는 것을 알 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;bak:~$ rustc --version
rustc 1.66.0 (69f9c33d7 2022-12-12)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;rust는 아래와 같이 세 가지 명령행 도구가 있습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;도구&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;cargo&lt;/td&gt;
      &lt;td&gt;전체 크레이트를 관리합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rustup&lt;/td&gt;
      &lt;td&gt;러스트 설치를 관리합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rustc&lt;/td&gt;
      &lt;td&gt;러스트 소스 코드의 컴파일을 관리합니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;rust-완전-삭제-방법&quot;&gt;Rust 완전 삭제 방법&lt;/h3&gt;

&lt;p&gt;삭제하는 방법은 간단 한데 아래와 같이 명령어만 입력하면 환경변수까지 모두 삭제가 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;bak:~$ rustup self uninstall
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;vs-code에서-rust-디버깅&quot;&gt;VS Code에서 Rust 디버깅&lt;/h2&gt;

&lt;p&gt;VS Code에서 Rust를 개발하기 위해서는 아래와 같이 세 가지 extension을 설치해주면 좋습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://code.visualstudio.com/docs/languages/rust#_installation&quot;&gt;VS code Install Rust&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Extension&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;rust-analyzer&lt;/td&gt;
      &lt;td&gt;rust의 자동완성, 구문강조 등 어시스트 기능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CodeLLDB&lt;/td&gt;
      &lt;td&gt;디버깅을 하기 위해 필요합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Better TOML&lt;/td&gt;
      &lt;td&gt;Rust의 설정 파일인 TOML 파일을 지원합니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;hello-world-만들기&quot;&gt;hello-world 만들기&lt;/h3&gt;

&lt;p&gt;rust는 cargo를 사용해서 프로젝트를 생성합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;bak:~$ cargo new hello_world
Created binary (application) `hello_world` package
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VS Code로 rust를 실행시키기 위해서는 프로젝트가 VS code의 root 디렉터리가 되어야 합니다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;그래서 아래와 같이 해당 프로젝트로 들어가 VS Code를 실행시켜야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;bak:~$ code hello_world
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;VS Code를 실행시키면 아래와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src&lt;/code&gt; 디렉터리에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.rs&lt;/code&gt; 파일이 있는 것을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2023-01-06-Rust_Install/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;디버깅&quot;&gt;디버깅&lt;/h3&gt;

&lt;p&gt;2번째 라인에 Break Point가 찍히는 것을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2023-01-06-Rust_Install/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 F5를 누르면 launch.json이 셋팅되지 않았다고 하며, 파일을 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2023-01-06-Rust_Install/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2023-01-06-Rust_Install/4.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;중요한 것을 지금 launch.json을 만들어도 F5로는 디버깅이 되지 않습니다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;왜냐하면 일반 계정의 vscode에서 cargo를 사용하기 위한 셋팅이 되지 않았기 때문입니다.&lt;/p&gt;

&lt;p&gt;터미널을 띄워 아래와 같이 입력합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;bak:~$ sudo ln -s /home/your_user_name/.cargo/bin/cargo /bin/cargo
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;저의 사용자 계정은 bak이기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;your_user_name&lt;/code&gt;에 bak을 입력하였습니다.&lt;/p&gt;

&lt;p&gt;이제 다시 F5를 눌러 launch.json을 만들게 되면 아래와 같이 만들어집니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;{
    // IntelliSense를 사용하여 가능한 특성에 대해 알아보세요.
    // 기존 특성에 대한 설명을 보려면 가리킵니다.
    // 자세한 내용을 보려면 https://go.microsoft.com/fwlink/?linkid=830387을(를) 방문하세요.
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;type&quot;: &quot;lldb&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;name&quot;: &quot;Debug executable 'hello_world'&quot;,
            &quot;cargo&quot;: {
                &quot;args&quot;: [
                    &quot;build&quot;,
                    &quot;--bin=hello_world&quot;,
                    &quot;--package=hello_world&quot;
                ],
                &quot;filter&quot;: {
                    &quot;name&quot;: &quot;hello_world&quot;,
                    &quot;kind&quot;: &quot;bin&quot;
                }
            },
            &quot;args&quot;: [],
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;
        },
        {
            &quot;type&quot;: &quot;lldb&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;name&quot;: &quot;Debug unit tests in executable 'hello_world'&quot;,
            &quot;cargo&quot;: {
                &quot;args&quot;: [
                    &quot;test&quot;,
                    &quot;--no-run&quot;,
                    &quot;--bin=hello_world&quot;,
                    &quot;--package=hello_world&quot;
                ],
                &quot;filter&quot;: {
                    &quot;name&quot;: &quot;hello_world&quot;,
                    &quot;kind&quot;: &quot;bin&quot;
                }
            },
            &quot;args&quot;: [],
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;
        }
    ]
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;https://github.com/rust-lang/vscode-rust/issues/708&lt;/li&gt;
  &lt;li&gt;https://rust-kr.org/pages/install/&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 06 Jan 2023 22:00:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/Rust_Install/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/Rust_Install/</guid>
        
        <category>Rust</category>
        
        <category>Linux</category>
        
        <category>VSCode</category>
        
        <category>설치</category>
        
        
        <category>Rust</category>
        
        <category>설치</category>
        
      </item>
    
      <item>
        <title>JWT의 Access Token과 Refresh Token</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;JWT를 사용하여 로그인을 구현하게 되면 아래와 같은 문제점에 부딪히게 됩니다.&lt;/p&gt;

&lt;p&gt;Token 방식의 인증은 제 3자에게 탈취 당할 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보안에 매우 취약합니다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;보안 상의 이유로 Access Token의 만료기간을 짧게 가진다면 사용자는 Token이 만료 될 때마다 매번 로그인을 새롭게 해야합니다.&lt;/p&gt;

&lt;p&gt;만료기간을 늘리면, Token을 탈취 당했을 때 보안에 더 취약해집니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유효기간을 짧게 하면서 좋은 방법이 있을까?&lt;/code&gt;라는 질문에 답은 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Refresh Token&lt;/code&gt;을 사용하는 방법 입니다.&lt;/p&gt;

&lt;h2 id=&quot;access-token과-refresh-token의-재발급-원리&quot;&gt;Access Token과 Refresh Token의 재발급 원리&lt;/h2&gt;

&lt;h4 id=&quot;1-로그인을-하게-되면-access-token과-refresh-token을-모두-발급합니다&quot;&gt;1. 로그인을 하게 되면 Access Token과 Refresh Token을 모두 발급합니다.&lt;/h4&gt;

&lt;p&gt;Refresh Token은 서버쪽에서 DB에 저장하며, 클라이언트 쪽에서는 Access Token과 Refresh Token을 쿠키 또는 웹 스토리지에 저장합니다.&lt;/p&gt;

&lt;h4 id=&quot;2-사용자가-인증이-필요한-api에-접근한다면-아래와-같이-유효성을-검사-합니다&quot;&gt;2. 사용자가 인증이 필요한 API에 접근한다면 아래와 같이 유효성을 검사 합니다.&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Case&lt;/th&gt;
      &lt;th&gt;동작&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Access Token과 Refresh Token 모두 만료가 된 경우&lt;/td&gt;
      &lt;td&gt;다시 로그인 하도록 유도하고 Access/Refresh Token 모두 새로 발급 합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Access Token은 만료 됐지만, Refresh Token은 유효 할 경우&lt;/td&gt;
      &lt;td&gt;Refresh Token을 검증하여, Access Token을 재발급 합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Access Token은 유효하지만, Refresh Token이 만료 됐을 경우&lt;/td&gt;
      &lt;td&gt;Access Token을 검증하여 Refresh Token을 재발급 합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Access Token과 Refresh Token 모두 유효 할 경우&lt;/td&gt;
      &lt;td&gt;정상적으로 사용 가능 합니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;3-로그아웃을-하게-되면-accessrefresh-token을-모두-만료시킵니다&quot;&gt;3. 로그아웃을 하게 되면 Access/Refresh Token을 모두 만료시킵니다.&lt;/h4&gt;

&lt;h2 id=&quot;refresh-token-인증-과정&quot;&gt;Refresh Token 인증 과정&lt;/h2&gt;

&lt;h4 id=&quot;정상적일-때&quot;&gt;정상적일 때&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-10-28-JWT_Refresh/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;access-token이-만료-되었을-때&quot;&gt;Access Token이 만료 되었을 때&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-10-28-JWT_Refresh/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-Access-Token-Refresh-Token-%EC%9B%90%EB%A6%AC-feat-JWT&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 28 Oct 2022 13:30:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/JWT_Refresh/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/JWT_Refresh/</guid>
        
        <category>보안</category>
        
        <category>인증</category>
        
        <category>Token</category>
        
        <category>JWT</category>
        
        
        <category>보안</category>
        
        <category>인증</category>
        
      </item>
    
      <item>
        <title>JWT(Json Web Token)</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;개발을 하다 보면 로그인 관련 기능을 만드는 경우가 많습니다.&lt;/p&gt;

&lt;p&gt;로그인은 쿠키(Cookie), 세션(Sessions) 등으로 많이 구현하는데, 토큰(Token)을 사용하는 방법도 있습니다.&lt;/p&gt;

&lt;p&gt;토큰을 사용하는 방법 중 JWT를 많이 사용하기에 JWT에 대해 정리하려고 합니다.&lt;/p&gt;

&lt;h2 id=&quot;jwt&quot;&gt;&lt;a href=&quot;https://jwt.io/introduction&quot;&gt;JWT&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;JWT(JSON Web Token)는 일반적으로 클라이언트(App FrontEnd)와 서버(App BackEnd)간에 정보를 공유하는 데 사용되는 개방형 산업 표준(RFC7519)입니다.&lt;/p&gt;

&lt;p&gt;JWT는 Token 자체를 정보로 사용하는 Self-Contained 방식이며, 필요한 모든 정보를 Token에 저장하기 때문에 서버와의 커뮤니케이션에서 오버헤드를 최소화 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;또한 JSON Content(JWT Claim이라고도 함)을 변경 할 수 없도록 암호화(해싱)되어 있습니다.&lt;/p&gt;

&lt;p&gt;아래는 Google에 로그인하면 Claim/JSON Payload가 포함 된 JWT를 발생합니다.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;iss&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;https://accounts.google.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;azp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1234987819200.apps.googleusercontent.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;aud&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1234987819200.apps.googleusercontent.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;sub&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;10769150350006150715113082367&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;at_hash&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;HK6E_P6Dh8Y93mRNtsDB1Q&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;email&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;jsmith@example.com&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;email_verified&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;iat&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1353601026&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;exp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1353604926&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;nonce&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0394852-3190485-2490358&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;hd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;example.com&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;jwt-구조&quot;&gt;JWT 구조&lt;/h2&gt;

&lt;p&gt;JWT는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Base64Url&lt;/code&gt;로 인코딩 되어 있고 마침표(.)로 구분 된 세 부분으로 구성되어 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;[header.payload.signature]

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.
tM-nO0TjFp-sF0-TYWjXKX_r9jEZvO1YWjKnWfIDWtM
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-10-18-JWT/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Header : Token 유형에 대한 메타데이터와 해당 콘텐츠를 보호하는 데 사용되는 암호화 알고리즘을 포함합니다.&lt;/li&gt;
  &lt;li&gt;Payload(Claim Set) : 사용자의 ID 및 허용 된 권한과 같은 검증 가능한 보안 설명이 포함 되어 있습니다.&lt;/li&gt;
  &lt;li&gt;Signature : Json Payload의 무결성을 확인하는 데 사용할 수 있는 암호화 알고리즘을 통해 생성 된 문자열 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아래 페이지에서 확인 가능 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://jwt.io/?_ga=2.110543749.1480193380.1666070190-535722928.1666070190&amp;amp;_gl=1*1a6ravf*rollup_ga*NTM1NzIyOTI4LjE2NjYwNzAxOTA.*rollup_ga_F1G3E656YZ*MTY2NjA3MDE4OS4xLjAuMTY2NjA3MDE4OS42MC4wLjA.&quot;&gt;JWT Debugger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-10-18-JWT/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;header&quot;&gt;Header&lt;/h4&gt;

&lt;p&gt;암호화 작업을 설명하는 매개변수가 포함 된 JSON 객체 입니다.&lt;/p&gt;

&lt;p&gt;사용 중인 알고리즘과 Type을 기술합니다.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;alg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;HS256&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;JWT&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;[JSON 객체]
Base64URLSafe(UTF-8('{&quot;alg&quot;: &quot;HS256&quot;,&quot;type&quot;: &quot;JWT&quot;}'))

[직렬화]
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;payload&quot;&gt;Payload&lt;/h4&gt;

&lt;p&gt;페이로드에는 엔티티(일반적인 사용자 정보)에 대한 설명과 Claim이라고 하는 추가 엔티티 속성이 포함 됩니다.&lt;/p&gt;

&lt;p&gt;아래 속성들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Claim Set&lt;/code&gt;이라 부른다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Claim Set
    &lt;ul&gt;
      &lt;li&gt;JWT에 대한 내용(토큰 생성자 정보, 생성 시간 등)&lt;/li&gt;
      &lt;li&gt;클라이언트와 서버 간 주고 받기로 한 값들로 구성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;sub&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1234567890&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;John Doe&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;admin&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;[JSON 객체]
Base64URLSafe(UTF-8('{&quot;sub&quot;: &quot;1234567890&quot;,&quot;name&quot;: &quot;John Doe&quot;,&quot;admin&quot;: true}'))

[직렬화]
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;signature&quot;&gt;Signature&lt;/h4&gt;

&lt;p&gt;서명은 JWT를 보낸 사람이 누구인지 확인하고 메시지가 도중에 변경되지 않았는지 확인하는 데 사용됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;[Signature]

HMACSHA256(
  base64UrlEncode(header) + &quot;.&quot; +
  base64UrlEncode(payload),
tqQWhz5BCP(your-256-bit-secret-key)
) 

[직렬화]
tM-nO0TjFp-sF0-TYWjXKX_r9jEZvO1YWjKnWfIDWtM
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;jwt-작동-원리&quot;&gt;JWT 작동 원리&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-10-18-JWT/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;사용자가 ID와 Password를 입력하여 로그인을 시도합니다.&lt;/li&gt;
  &lt;li&gt;서버는 요청을 확인하고 Secret Key를 통해 Access Token을 발급합니다.&lt;/li&gt;
  &lt;li&gt;JWT 토큰을 클라이언트에 전달합니다.&lt;/li&gt;
  &lt;li&gt;클라이언트에서 API을 요청할 때, 클라이언트가 Authorization Header에 Access Token을 담아서 보냅니다.&lt;/li&gt;
  &lt;li&gt;서버는 JWT Signature를 체크하고 Payload로 부터 사용자 정볼르 확인해 데이터를 반환합니다.&lt;/li&gt;
  &lt;li&gt;클라이언트의 로그인 정보를 서버 메모리에 저장하지 않기 때문에 토큰 기반 인증 메커니즘을 제공합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;인증이 필요한 경로에 접근 할 때 서버 측은 Authorization 헤더에 유효한 JWT 또는 존재하는지 확인한다.&lt;/p&gt;

&lt;p&gt;JWT에는 필요한 모든 정보를 토큰에 포함하기 때문에 데이터베이스와 같은 서버와의 커뮤니케이션 오버 헤드를 최호화 할 수 있다.&lt;/p&gt;

&lt;p&gt;Cross-Origin Resources Sharing(CORS)는 쿠키를 사용하지 않기 때문에 JWT를 채용 한 인증 메커니즘은 두 도메인에서 API를 제공하더라도 문제가 발생하지 않습니다.&lt;/p&gt;

&lt;p&gt;일반적으로 JWT 토큰 기반의 인증 시스템은 위와 같은 프로세스로 이루어집니다. 처음 사용자를 등록 할 때 Access Token과 Refresh token이 모두 발급되어야 합니다.&lt;/p&gt;

&lt;h2 id=&quot;jwt-장단점&quot;&gt;JWT 장단점&lt;/h2&gt;

&lt;h4 id=&quot;장점&quot;&gt;장점&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;보안 : JWT는 클라이언트나 해커가 수정하지 못하도록 보호하는 비밀(HMAC) 또는 공개/개인 키 쌍(RSA 또는 ECDSA)를 사용하여 디지털 서명됩니다.&lt;/li&gt;
  &lt;li&gt;클라이언트에만 저장 : 서버에서 JWT를 생성하여 클라이언트로 보냅니다. 그런 다음 클라이언트는 모든 요청과 함께 JWT를 제출합니다. 이것은 데이터베이스의 공간을 절약 할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;Efficient / Stateless : 데이터베이스 조회가 필요하지 않기 때문에 JWT를 빠르게 검증 할 수 있습니다. 이는 대규모 분산 시스템에서 특히 유용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;단점&quot;&gt;단점&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;취소 기능 : 자체 포함 된 속성 및 상태 확인 프로세스로 인해 JWT가 자연적으로 만료 되기 전에는 취소하기가 어렵습니다. 따라서 사용자를 즉시 차단하는 것과 같은 조치는 쉽게 구현 할 수 없습니다. (&lt;a href=&quot;https://supertokens.com/blog/revoking-access-with-a-jwt-blacklist&quot;&gt;JWT 거부 및 블랙리스트&lt;/a&gt;로 취소 가능 하지만 어렵습니다.)&lt;/li&gt;
  &lt;li&gt;사용자 정보 수정 : 취소 기능가 마찬가지로 발급 된 JWT는 수정이 불가능 하기 때문에 사용자의 정보를 데이터베이스에서 수정 했더라도 즉시 적용이 어렵습니다.&lt;/li&gt;
  &lt;li&gt;1개의 Private 키 종속적 : JWT는 1개의 Private 키에 따라 달라집니다. 해당 키가 손상되면 공격자는 API 계층이 수락할 자체 JWT를 조작 할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;트래픽 : Stateless 애플리케이션에서 토큰은 거의 모든 요청에 대해 전송 되므로 데이터 트래픽이 증가 할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;claim&quot;&gt;Claim&lt;/h2&gt;

&lt;p&gt;JWT는 Claim에 이름/값 쌍으로 여러 정보를 넣을 수 있습니다. JWT Claim에는 아래와 같은 두 가지 유형이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Registered&lt;/code&gt; : 등록 된 &lt;a href=&quot;https://www.iana.org/assignments/jwt/jwt.xhtml&quot;&gt;표준 Claim&lt;/a&gt;에 의해 정의되고 &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc7519&quot;&gt;JWT 사양&lt;/a&gt; 타사 또는 외부 응용 프로그램과의 상호 운용성을 보장합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Custom&lt;/code&gt; : 등록 되지 않은 public 또는 private claim으로 구성 됩니다.
    &lt;ul&gt;
      &lt;li&gt;Public Claim : JWT를 사용하는 사람들 마음대로 정의 할 수 있습니다. 그러나 충돌을 방지하려면 &lt;a href=&quot;https://www.iana.org/assignments/jwt/jwt.xhtml&quot;&gt;IANA JWT Registry&lt;/a&gt;에 등록해야 합니다.&lt;/li&gt;
      &lt;li&gt;Private Claim : Private으로 당사자 간의 정보를 공유하기 위해 생성 하는 맞춤형 Claim입니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;registered-claim&quot;&gt;Registered Claim&lt;/h3&gt;

&lt;p&gt;JWT 사양은 필수는 아니지만 상호 운용성을 위해 아래와 같이 권장하는 7개의 예약 Claim이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iss(발급자)&lt;/code&gt; : JWT 발행자&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sub(주제)&lt;/code&gt; : JWT의 주제(사용자)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aud(청중)&lt;/code&gt; : JWT가 의도 된 수신자&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exp(만료 시간)&lt;/code&gt; : JWT가 만료되는 시간&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nbf(not before time)&lt;/code&gt; : JWT가 처리를 위해 수락 되어서는 안 되는 시간&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iat(발행 시간)&lt;/code&gt; : JWT가 발행 된 시간. JWT의 나이를 결정하는 데 사용 할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jti(JWT ID)&lt;/code&gt; : 고유 식별자. JWT가 재생되는 것을 방지함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;custom-claim&quot;&gt;Custom Claim&lt;/h3&gt;

&lt;p&gt;사용자가 자신에게 맞는 Claim을 정의하고 Actions를 사용하여 토큰을에 추가 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;아래와 같이 사용 가능 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자의 이메일 주소를 액세스 토큰에 추가하고 이를 사용하여 사용자를 고유하게 식별합니다.&lt;/li&gt;
  &lt;li&gt;Auth0 사용자 프로필에 저장 된 사용자 지정 정보를 ID 토큰에 추가합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;1-public-claim&quot;&gt;1. Public Claim&lt;/h4&gt;

&lt;p&gt;이름 및 이메일과 같은 일반 정보를 포함할 수 있는 공개 사용을 위한 사용자 지정 Claim을 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;공개 Claim을 생성하는 경우 이를 등록하거나 네임스페이스를 통해 충돌 방지 이름을 사용하야 합니다. 아래는 IANA JWT Registry](https://www.iana.org/assignments/jwt/jwt.xhtml)에 등록 된 Public Claim 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth_time&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acr&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonce&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-private-claim&quot;&gt;2. Private Claim&lt;/h4&gt;

&lt;p&gt;개인 사용자 지정 Claim을 만들어 응용 프로그램과 관련 된 정보를 공유할 수 있습니다.&lt;/p&gt;

&lt;p&gt;예를 들어 Public Claim 같은 경우 이름 및 이메일과 같은 일반적인 정보라면 Private Claim은 직원 ID, 부서 이름과 같은 더 구체적인 Claim을 만들 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;https://jwt.io/introduction&lt;/li&gt;
  &lt;li&gt;https://supertokens.com/blog/what-is-jwt&lt;/li&gt;
  &lt;li&gt;http://www.opennaru.com/opennaru-blog/jwt-json-web-token/&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 18 Oct 2022 13:30:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/JWT/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/JWT/</guid>
        
        <category>보안</category>
        
        <category>인증</category>
        
        <category>Token</category>
        
        <category>JWT</category>
        
        
        <category>보안</category>
        
        <category>인증</category>
        
      </item>
    
      <item>
        <title>Visitor 패턴</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;패턴을 활용한 리팩터링이라는 책에서 Switch 문을 좀더 객체지향적인, 다향성을 이용하도록 리팩터링 하기 위해서 Visitor 패턴을 도입하면, 조건 로직도 필요 없어지고 설계도 더 융통성 있게 할 수 있다고 소개한다.&lt;/p&gt;

&lt;h2 id=&quot;방문자-패턴visitor-pattern&quot;&gt;방문자 패턴(Visitor Pattern)&lt;/h2&gt;

&lt;p&gt;Visitor는 사전적인 의미로 어떤 장소에 찾아오는 사람이라는 의미를 가지고 있다. 방문자 패턴에서는 데이터 구조와 처리를 분리한다.&lt;/p&gt;

&lt;p&gt;데이터 구조 안을 돌아다니는 주체인 방문자를 나타내는 클래스를 준비해서 처리를 맡긴다. 새로운 처리를 추가하고 싶을 땐 새로운 방문자를 만들고 데이터 구조는 방문자를 받아들이면 된다.&lt;/p&gt;

&lt;p&gt;방문자 패턴은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;개방-패쇠 원칙&lt;/code&gt;을 적용하는 방법 중 한 가지 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;확장에 대해 열려있다.
    &lt;ul&gt;
      &lt;li&gt;클래스를 설계할 때, 특별한 이유가 없는 한 확장을 금지해서는 안된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;수정에 대해 닫혀있다.
    &lt;ul&gt;
      &lt;li&gt;확장 할 때 마다 기존의 클래스를 수정하면 안된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-09-14-VisitorPattern/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Visitor&lt;/code&gt;은 객체 구조의 각 ConcreteElement에 대한 메서드을 정의합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcreteVisitor&lt;/code&gt;은 Visitor에 의해 정의된 각 메서드를 구현합니다. 각 메서드는 해당 개체에 필요한 알고리즘을 구현합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Eelement&lt;/code&gt;는 Visitor를 인수로 사용하는 Accept 메서드를 정의 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcreteElement&lt;/code&gt;는 방문자를 인수로 하는 Accept 메서드를 구현합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectStructure&lt;/code&gt;는 Element를 열거할 수 있으며 Visitor가 Element를 방문할 수 있도록 높은 수준의 인터페이스를 제공합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;예시&quot;&gt;예시&lt;/h2&gt;

&lt;p&gt;맛집 레스토랑을 예시로 설명을 해보도록 하겠습니다. 직원들이 열심히 일을 해 손님들이 항상 꽉차고 매출도 많이 오른 레스토랑이 있습니다.&lt;/p&gt;

&lt;p&gt;그래서 사장은 보너스와 휴가를 줌으로써 직원들에게 보상하려고 합니다.&lt;/p&gt;

&lt;p&gt;하지만 이미 아래와 같이 직원의 클래스가 이미 만들어져 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;classDiagram

    Employee &amp;lt;|--GeneralManager
    Employee &amp;lt;|--HeadChef
    Employee &amp;lt;|--LineCook

    class Employee{
        +string Name
        +double AnnualSalary
        +int PaidTimeOffDays
    }

    class GeneralManager{
    }

    class HeadChef{
    }

    class LineCook{
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;우리는 여기서 직원들의 보너스와 추가 휴가에 대해 계산하여 출력하려 합니다.&lt;/p&gt;

&lt;p&gt;물론 List에 모든 직원들을 넣어 반복문을 돌면서 보너스를 계산하는 메서드, 추가 휴가를 계산하는 메서드를 만들 수 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 Visitor 패턴을 사용하게 되면 좀 더 객체지향적으로 계산할 수 있으며, 추후 다른 필요한 계산에 대해 모듈을 만들어 추가 및 삭제가 용이하게 만들 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IVisitor&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IElement&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IVisitor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IncomeVisitor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IVisitor&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AnnualSalary&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{0} {1}' new income: {2:C}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AnnualSalary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PaidTimeOffVisitor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IVisitor&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IElement&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PaidTimeOffDays&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{0} {1}'s new vacation days: {2}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PaidTimeOffDays&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;IncomeVisitor : 보너스 계산에 쓰입니다.&lt;/li&gt;
  &lt;li&gt;PaidTimeOffVisitor : 추가 휴가에 쓰입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같이 Visitor를 따로따로 만들어 필요할때마다 가져다 사용하면 됩니다.&lt;/p&gt;

&lt;p&gt;기존의 Employee 클래스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IElement&lt;/code&gt;를 상속 받아 구현합니다.&lt;/p&gt;
&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IElement&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AnnualSalary&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PaidTimeOffDays&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;annualSalary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;paidTimeOffDays&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;AnnualSalary&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;annualSalary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;PaidTimeOffDays&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;paidTimeOffDays&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IVisitor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;visitor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Visit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 직원들의 리스트를 가질 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Employees&lt;/code&gt; 클래스를 생성합니다.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Employees&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_employees&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Attach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_employees&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Detach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_employees&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IVisitor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visitor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Employee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_employees&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visitor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Program.cs&lt;/code&gt; 파일에서 아래와 같이 필요한 직원들을 추가하고 계산 할 Visitor를 넣어 실행 시킵니다.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;Employees&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Employees&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Attach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LineCook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Attach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;HeadChef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Attach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GeneralManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IncomeVisitor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PaidTimeOffVisitor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ReadKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;LineCook Dmitri' new income: \35,200
HeadChef Jackson' new income: \75,916
GeneralManager Amanda' new income: \85,800

LineCook Dmitri's new vacation days: 10
HeadChef Jackson's new vacation days: 24
GeneralManager Amanda's new vacation days: 27
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;고려할-점들&quot;&gt;고려할 점들&lt;/h2&gt;

&lt;p&gt;Visitor 패턴을 사용 할 때는 캡슐화에 대해 고려해 볼 점이 있다.&lt;/p&gt;

&lt;h4 id=&quot;장점&quot;&gt;장점&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;기존 클래스를 수정하지 않고 새로운 동작을 추가할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;생각하지 못했던 연산을 쉽게 추가할 수 있다.&lt;/li&gt;
  &lt;li&gt;드믈게 사용되는 연산을 외부에 정의 할 수 있기 때문에 클래스가 작아진다.&lt;/li&gt;
  &lt;li&gt;Visitor는 원소들을 방문하면서 상태를 축적할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모바일 에이전트&lt;/code&gt;는 리모트 객체(예를 들어 데이터베이스 서버)에 방문하여 분산 데이터베이스로부터 합성 결과를 축적할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;단점&quot;&gt;단점&lt;/h4&gt;

&lt;p&gt;합성 객체의 내부 구조가 Visitor에 열리게 되고, 이는 캡슐화를 위반하는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어 트리의 원소에 넘겨진 사악한 Visitor가 이들의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;키&lt;/code&gt; 값을 바꾼다면 트리는 쓰레기가 되어 버린다. 또한 Visitor는 그들이 방문하는 객체와 강결합되어 있다.&lt;/p&gt;

&lt;h4 id=&quot;캡슐화-위반에-대한-반론&quot;&gt;캡슐화 위반에 대한 반론&lt;/h4&gt;

&lt;p&gt;어떤 프로그래머들은 이런저런 이유로 Visitor 패턴 사용을 반대하기도 한다. 예를 들어 어떤 프로그래머는 Visitor 패턴이 캡슐화 원칙에 위배되기 때문에 좋아하지 않는다고 말한적이 있다. 즉, Visitor 클래스가 대상 클래스의 어떤 메서드를 사용해야 하는데 그 메서드가 public 이 아니라면 그 메서드의 접근 제한을 풀어야 하고, 이것이 캡슐화 특성으 깨뜨린다는 주장이다.&lt;/p&gt;

&lt;p&gt;옳은 말이다. 하지만 Visitor 패턴을 구현할 때 대부분의 경우 그럴 필요가 없다. 설사 몇몇 메서드의 접근 제한을 풀어줘야 하는 경우라도, Visitor 패턴을 사용하지 않고 코드를 꾸려가는 것보다 대상 클래스의 캡슐화 특성을 양보하는 편이 처러야 하는 대가가 훨씬 적을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;https://velog.io/@newtownboy/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4-%EB%B0%A9%EB%AC%B8%EC%9E%90%ED%8C%A8%ED%84%B4Visitor-Pattern&lt;/li&gt;
  &lt;li&gt;https://johngrib.github.io/wiki/pattern/visitor/&lt;/li&gt;
  &lt;li&gt;https://nipafx.dev/java-visitor-pattern-pointless/&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 14 Sep 2022 10:30:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/VisitorPattern/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/VisitorPattern/</guid>
        
        <category>Design Pattern</category>
        
        <category>Visitor</category>
        
        
        <category>Design Pattern</category>
        
        <category>Visitor</category>
        
      </item>
    
      <item>
        <title>페이지 교체 기법</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;h2 id=&quot;메모리-관리-배경&quot;&gt;메모리 관리 배경&lt;/h2&gt;

&lt;p&gt;각각의 프로세스는 독립된 메모리 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있다. 단지, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;운영체제&lt;/code&gt;만이 운영체제 메모리 영역과 사용자 메모리 영역에 접근을 제약을 받지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;페이징&quot;&gt;페이징&lt;/h2&gt;

&lt;p&gt;하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 업애는 메모리 관리 방법이다. 외부 단편화와 압축 작업을 해소하기 위해 생긴 방법론으로, 물리 메모리는 Frame이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리 된다.&lt;/p&gt;

&lt;p&gt;페이징 기법을 사용함으로써 논리 메모리를 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있는 큰 장점이 있다.&lt;/p&gt;

&lt;p&gt;하나의 프로세스가 사용하는 공간을 여러개의 페이지로 나뉘어서 관리되고(논리 메모리에서), 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping되어 저장 된다고 볼 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;요구-페이징demand-paging&quot;&gt;요구 페이징(Demand Paging)&lt;/h2&gt;

&lt;p&gt;프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;요구 페이징&lt;/code&gt;이라 하며, 가상 메모리 시스템에서 많이 사용된다.&lt;/p&gt;

&lt;p&gt;그리고 가상 메모리는 대게 페이지로 관리된다. 요구 페이징을 사용하는 가상 메모리에서는 실행과정에서 필요해질 때 페이지들이 적재된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;한 번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않는다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;프로세스 내 개별 페이지들은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;페이저(pager)&lt;/code&gt;에 의해 관리된다. 페이저는 프로세스 실행에 실제 필요한 페이지들만 메모리에 읽어 옴으로써, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사용되지 않을 페이지를 가져오는 시간 낭비와 메모리 낭비를 줄일 수 있다.&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;페이지-교체&quot;&gt;페이지 교체&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;요구 페이지&lt;/code&gt;에서 언급된대로 프로그램 실행시에 모든 항목이 물리 메모리에 올라오지 않기 때문에, 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;page fault(페이지 부재)&lt;/code&gt;가 발생하게 되면, 원하는 페이지를 보조저장장치로 가져오게 된다. 하지만, 만약 물리 메모리가 모두 사용중인 상황이라면, 페이지 교체가 이뤄줘야 한다. (또는 운영체제가 프로세스를 강제 종료하는 방법이 있다.)&lt;/p&gt;

&lt;h4 id=&quot;페이지-교체-방법&quot;&gt;페이지 교체 방법&lt;/h4&gt;

&lt;p&gt;물리 메모리가 모두 사용중인 상황에서 메모리 교체 흐름이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디스크에서 필요한 페이지의 위치를 찾는다.&lt;/li&gt;
  &lt;li&gt;빈 페이지 프레임을 찾는다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;페이지 교체 알고리즘&lt;/code&gt;을 통해 희생될 페이지를 고른다.&lt;/li&gt;
      &lt;li&gt;희생될 페이지를 디스크에 기록하고, 관련된 테이블을 수정한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.&lt;/li&gt;
  &lt;li&gt;사용자 프로세스 재시작&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;페이지-교체-알고리즘&quot;&gt;페이지 교체 알고리즘&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;운영체제는 주기억장치보다 더 큰 용량의 프로그램을 실행하기 위해 프로그램의 일부만 주기억장치에 적재하여 사용한다. 이를 가상메모리 기법이라 한다.&lt;/li&gt;
  &lt;li&gt;페이징 기법으로 메모리를 간리하는 운영체제에서 필요한 페이지가 주기억장치에 적재되지 않았을 시 (페이지 부재) 어떤 페이지 프레임을 선택하여 교체할 것인지 결정하는 방법을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;페이지 교체 알고리즘&lt;/code&gt;이라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;프레임 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;물리 메모리&lt;/code&gt;를 일정한 크기로 나눈 블록 &lt;br /&gt;
페이지 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가상 메모리&lt;/code&gt;를 일정한 크기로 나눈 블록&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;알고리즘&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;OPT(Optimal)&lt;/td&gt;
      &lt;td&gt;앞으로 가장 오랫동안 사용되지 않을 페이지 교체&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FIFO(First In First Out)&lt;/td&gt;
      &lt;td&gt;먼저 들어온 페이지가 먼저 나가게 된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LRU(Least Recently Used)&lt;/td&gt;
      &lt;td&gt;가장 오랫동안 사용되지 않은 페이지 교체&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LFU(Least Frequently Used)&lt;/td&gt;
      &lt;td&gt;참조 횟수가 가장 작은 페이지 교체&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;1-oproptimal-page-replacement&quot;&gt;1. OPR(Optimal Page Replacement)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-08-01-PageReplacement/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Belady의 모순&lt;/code&gt;을 확인한 이후 최적 교체 알고리즘에 대한 탐구가 진행되었고, 모든 알고리즘 보다 낮은 부재율을 보이며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Belady의 모순&lt;/code&gt;이 발생하지 않는다.&lt;/p&gt;

&lt;p&gt;이 알고리즘의 핵심은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체&lt;/code&gt;하는 것이다. 주료 비교 연구 목적으로 사용 된다.&lt;/p&gt;

&lt;h4 id=&quot;장점&quot;&gt;장점&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;알고리즘 중 가장 낮은 페이지 부재율을 보장한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;단점&quot;&gt;단점&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;구현의 어려움이 있다. 모든 프로세스의 메모리 참조 계획을 미리 파악할 방법이 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-fifofirst-in-first-out&quot;&gt;2. FIFO(First In First Out)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-08-01-PageReplacement/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가장 간단한 페이지 교체 알고리즘으로 먼저 물리 메모리에 들어온 순서대로 페이지 교체 시점에 먼저 나가게 된다.&lt;/p&gt;

&lt;h4 id=&quot;장점-1&quot;&gt;장점&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;이해하기 쉽고, 프로그램하기도 쉽다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;단점-1&quot;&gt;단점&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;오래된 페이지가 항상 불필요하지 않은 정보를 포함하지 않을 수 있다. ( 초기 변수 등)&lt;/li&gt;
  &lt;li&gt;처음부터 활발하게 사용되는 페이지를 교체해서 페이지 내 부재율을 높이는 부작용을 초래할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Belady의 모순&lt;/code&gt; : 페이지를 저장 할 수 있는 페이지 프레임의 갯수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-lruleast-recently-used&quot;&gt;3. LRU(Least Recently Used)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-08-01-PageReplacement/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가장 오랫동안 사용하지 않았던 데이터라면 앞으로도 사용할 확률이 적을 것이다. 라는 가정을 가지고 동작한다.&lt;/p&gt;

&lt;h4 id=&quot;특징&quot;&gt;특징&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;국부성(locality)에 기반 : 어느 한순간에 특정 부분을 집중적으로 참조&lt;/li&gt;
  &lt;li&gt;시간 국부성 : 현재 참조된 기억장소는 가까운 미래에도 계속 참조될 가능성이 높음&lt;/li&gt;
  &lt;li&gt;공간 국부성 : 하나의 기억장소가 참조되면 근처의 기억 장소가 계속 참조될 가능성이 높음&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;장점-2&quot;&gt;장점&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Belady의 모순&lt;/code&gt;이 발생하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;단점-2&quot;&gt;단점&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;경험적 판단이 맞지 않는 상환도 존재&lt;/li&gt;
  &lt;li&gt;막대한 오버헤드 발생&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-lfuleast-frequently-used&quot;&gt;4. LFU(Least Frequently Used)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-08-01-PageReplacement/4.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;참조 횟수가 가장 적은 페이지를 교체하는 방법이다. 활발하게 사용되는 페이지는 참조 횟수가 많아질 것이라는 가정에서 만들어진 알고리즘이다.&lt;/p&gt;

&lt;p&gt;페이지가 참조 될 때마다 증가된 횟수를 기록하고 참조 횟수가 가장 적은 페이지를 교체 한다.&lt;/p&gt;

&lt;h4 id=&quot;단점-3&quot;&gt;단점&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;가장 최근에 메모리로 옮겨진 페이지가 교체될 가능성이 높다.&lt;/li&gt;
  &lt;li&gt;초기에 매우 많이 사용된 후 더 이상 사용되지 않는 페이지는 교체 가능성이 낮다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 01 Aug 2022 14:30:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PageReplacement/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PageReplacement/</guid>
        
        <category>OS</category>
        
        <category>Memory</category>
        
        <category>Cache</category>
        
        
        <category>OS</category>
        
        <category>Cache</category>
        
      </item>
    
      <item>
        <title>상속에서 Dispose 패턴</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;C#에서는 가비즈 컬렉터(GC)가 메모리를 자동으로 관리합니다. 필요없는 클래스의 인스턴스를 메모리에서 바로 지우는 것이나라, 조건을 만족할 때까지 기다렸다가 지우기 때문에 클래스를 지웠다고 해도 메모리가 바로 해제 되지 않는다.&lt;/p&gt;

&lt;p&gt;일반적인 메모리라면 GC에 맡겨도 상관 없지만, 관리되지 않는(Unmanaged, Native)리소스는 즉각 해제해야 하는 경우가 생기는데, 그럴때 필요한 것이 Dispose다.&lt;/p&gt;

&lt;h2 id=&quot;idisposable-인터페이스&quot;&gt;IDisposable 인터페이스&lt;/h2&gt;

&lt;p&gt;C#에서는 개발자가 명시적으로 메모리를 해제하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IDisposable&lt;/code&gt; 인터페이스를 상속 받아 구현한다.&lt;/p&gt;

&lt;p&gt;IDisposable에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dispose()&lt;/code&gt; 하나의 메서드만 제공한다.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IDisposable&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;IDisposable.Dispose()는 다음 4가지 작업을 수행한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모든 비관리 리소스를 정리한다.&lt;/li&gt;
  &lt;li&gt;모든 관리 리소스를 정리한다.&lt;/li&gt;
  &lt;li&gt;객체가 이미 정리되었음을 나타내기 위한 상태 플래그 설정. 앞서 이미 정리된 객체에 대하여 추가로 정리 작업이 요청될 경우 이 플래그를 확인하여 ObjectDisposed예외를 발생시킨다.&lt;/li&gt;
  &lt;li&gt;finalizer 호출 회피. 이를 위해 GC.SupressFinalize(this)를 호출한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;idisposable의-일반적인-사용법&quot;&gt;IDisposable의 일반적인 사용법&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/ko-kr/dotnet/api/system.idisposable?view=net-6.0&quot;&gt;MSDN 참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DisposeExample&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyResource&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDisposable&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 외부 비관리 리소스 핸들&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;component&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 관리 리소스&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;disposed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Dispose가 호출되었는지 확인한다.&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MyResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Handle&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;disposing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// 사용자가 직접 Dispose()를 호출했기 때문에 &lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// GC는 finalizer를 호출할 필요가 없다.&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// GC는 finalizer를 구현한 인스턴스에 대해 finalizer를 호출한다.&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;GC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;SuppressFinalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// disposing이 true인 경우 사용자가 직접 호출하여&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 해당 인스턴스의 관리/비관리 리소스를 해제하고 있는 것이다.&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// disposing이 false인 경우, finalizer에 의해 호출되어&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 다른 객체를 더 이상 참조하면 안되기 때문에 오직 비관리 리소스만 해제되어야한다.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;disposing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 이미 리소스가 해제 되었는지 확인&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;disposed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// 실제로 사용자가 호출한 경우에만 &lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 관리 리소스를 호출한다.&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;disposing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// 비관리 리소스를 해제하기 위해&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 올바른 함수를 호출한다.&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;CloseHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Handle&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IntPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Zero&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// 이제 해당 인스턴스는 모두 해제되었다.&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;disposed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// C# finalizer는 비관리 리소스만 해제해야한다.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;MyResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;disposing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;protected&lt;/code&gt;로 선언된 가상 헬퍼함수(virtual hepler function)을 제공하는데 파생 클래스에게도 리소스를 정리하도록 제공할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;protected&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isDisposing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;disposing이 true일 경우는 관리/비관리 리소스를 모두 해제 합니다.&lt;/li&gt;
  &lt;li&gt;disposing이 false일 경우는 비관리 리소스만 정리합니다.&lt;/li&gt;
  &lt;li&gt;코드의 마지막 부분에서는 반드시 베이스 클래서에서 정의하는 Dispose를 호출해야만 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자식-클래스에서-dispose-사용법&quot;&gt;자식 클래스에서 Dispose 사용법&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;classDiagram
IDisposable &amp;lt;|--ParentClase
ParentClase &amp;lt;|--ChildClass

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이미 BaseClass에서 IDisposable를 구현했을 때 Child 클래스에서만 사용하는 리소스의 메모리 해제 방법에 대해 알아봅니다.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ParentClase&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDisposable&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_parentComponent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_disposed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ParentClase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;GC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;SuppressFinalize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;disposing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_disposed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;disposing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_parentComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_disposed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ChildClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParentClase&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_disposed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Component&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_childComponent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ChildClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;disposing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_disposed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;disposing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_childComponent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;_disposed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;disposing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ParentClass&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChildClass&lt;/code&gt;의 Dispose가 호출되는 것을 확인하지 않고 Dispose 해버리면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChildClass&lt;/code&gt;의 메모리는 해제 되지 않습니다.&lt;/p&gt;

&lt;h4 id=&quot;dispose-pattern-구현-시-주의-사항&quot;&gt;Dispose Pattern 구현 시 주의 사항&lt;/h4&gt;

&lt;p&gt;Dispose와 Finalizer는 방어적으로 작성되어야 합니다. Dispose 메서드는 한번 이상 호출 될 수 있으므로, 여러번 호출해도 문제가 없도록 구현해야 합니다.&lt;/p&gt;

&lt;p&gt;만약 이미 정리된 객체에 대해 호출한 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ObjectDisposedException&lt;/code&gt;예외를 발생시키는 것 또한 Dispose 패턴의 규칙이다.&lt;/p&gt;

&lt;p&gt;Dispose 메서드에서는 리소스 정리 작업만 수행해야 한다. Dispose나 Finalizer에서 다른 작업을 수행하게 되면 객체의 생명주기와 관련된 심각한 문제를 일으킬 수 잇따. 만약 Finalizer에서 객체에 접근하여 다른 작업을 수행하면 객체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reachable&lt;/code&gt; 상태로 되어 객체가 죽지 않고 다시 살아 날수 있다.&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Jun 2022 15:30:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/Impl_Dispose_Pattern/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/Impl_Dispose_Pattern/</guid>
        
        <category>.NET</category>
        
        <category>Pattern</category>
        
        <category>Dispose</category>
        
        
        <category>.NET</category>
        
        <category>Pattern</category>
        
      </item>
    
      <item>
        <title>27장. '크고 작은 모든' 서비스들</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-19-PPPCleanArchitecture_ch27/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;크고-작은-모든-서비스들&quot;&gt;‘크고 작은 모든’ 서비스들&lt;/h1&gt;

&lt;p&gt;서비스 지향 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;아키텍처&lt;/code&gt;와 마이크로서비스 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;아키텍처&lt;/code&gt;가 최근 큰 인기를 끌고 있는 이유는 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서비스를 사용하면 상호 결합이 철저하게 분리되는 것처럼 보인다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;나중에 보겠지만, 일부만 맞는 말이다.&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;서비스를 사용하면 개발과 배포 독립성을 지원하는 것처럼 보인다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;나중에 보겠지만, 일부만 맞는 말이다.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;서비스-아키텍처&quot;&gt;서비스 아키텍처?&lt;/h2&gt;

&lt;p&gt;서비스를 사용한다는 것인 본질적으로 아키텍처에 해당하는가? 개념적으로는 아니다. 시스템의 아키텍처는 의존성 규칙을 준수하며 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의 된다.&lt;/p&gt;

&lt;p&gt;단순히 애플리케이션의 행위를 분리할 뿐인 서비스라면 값비싼 함수 호출에 불과하다.&lt;/p&gt;

&lt;p&gt;결국 서비스는 프로세스나 플랫폼 경계를 가로지르는 함수 호출에 불과 하다. 아키텍처적으로 중요한 서비스도 있지만, 중요하지 않는 서비스도 존재한다.&lt;/p&gt;

&lt;h2 id=&quot;서비스의-이점&quot;&gt;서비스의 이점?&lt;/h2&gt;

&lt;h3 id=&quot;결합-분리의-오류&quot;&gt;결합 분리의 오류&lt;/h3&gt;

&lt;p&gt;시스템을 서비스들로 분리함으로써 얻는 이점은 서비스 사이의 결합이 확실히 분리된다는 점이다. 물론 서비스는 개별 변수 수준에서는 각각 결합이 분리된다. 하지만 프로세서 내의 또는 네트워크 상의 공유 자원 때문에 결합 될 가능성이 여전히 존재한다. 더욱이 서로 공유하는 데이터에 의해 이들 서비스는 강력하게 결합되어 버린다.&lt;/p&gt;

&lt;h2 id=&quot;개발-및-배포-독립성의-오류&quot;&gt;개발 및 배포 독립성의 오류&lt;/h2&gt;

&lt;p&gt;서비스를 사용함에 따라 예측되는 또 다른 이점은 전담팀이 서비스를 소유하고 운영한다는 점이다. 그래서 데브옵스(dev-ops) 전략의 일환으로 전담팀에서 각 서비스를 작성하고, 유지보수하며, 운영하는 책임을 질 수 있다. 이러한 개발 및 배포 독립성은 확장 가능한(scalable)것으로 간주 된다.&lt;/p&gt;

&lt;p&gt;대규모 엔터프라이즈 시스템을 독립적으로 개발하고 배포 가능한 수십, 수백, 수천 개의 서비스들을 이용하여 만들 수 있다고 믿는다. 시스템의 개발, 유지보수, 운영 또한 비슷한 수의 독립적인 팀 단위로 분할할 수 있다고 여긴다.&lt;/p&gt;

&lt;p&gt;하지만 이는 일부일 뿐이다. 첫째로 대규모 인터프라이즈 시스템은 서비스 기반 시스템 이외에도 모노리틱, 컴포넌트 기반 등 다른 방식으로 구축할 수 있다.&lt;/p&gt;

&lt;p&gt;둘째, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결합 분리의 오류&lt;/code&gt;에 따르면 서비스라고 해서 항상 독립적으로 개발하고, 배포 운영 할 수 있는 것이 아니다. 데이터나 행위에서 어느정도 결합되어 있다면 결합된 정도에 맞게 개발, 배포, 운영을 조정해야만 한다.&lt;/p&gt;

&lt;h2 id=&quot;야옹이-문제&quot;&gt;야옹이 문제&lt;/h2&gt;

&lt;p&gt;앞의 두 가지 오류에 대한 예로 9장에 예를 들었던 택시 통합 시스템을 다시 살펴보자. 고객은 승차 요청을 할 수 있다. 고객은 승차 시간, 비용, 고급 택시 여부, 운전자 경력 등 다양한 기준에 따라 택시를 선택 할 수 있다.&lt;/p&gt;

&lt;p&gt;확장 가능한 시스템을 구축하고 싶었기에, 수많은 작은 마이크로서비스를 기반으로 구축하였다. 아래의 다이어그램은 TaxiUI 서비스는 고객을 담당하며, 고객은 모바일 기기로 호출한다. Taxi Finder가 여러 Taxi Supplier를 찾아 적합한 택시 후보를 고객에게 보여준다.&lt;/p&gt;

&lt;p&gt;TaxiSelector서비스는 사용자가 지정한 비용, 시간, 고급 여부 등의 조건으로 적합한 택시를 선택한다. TaxiSelector가 해당 택시를 TaxiDispatcher 서비스로 전달하면, TaxiDispatcher 서비스는 해당 택시에 배차를 지시한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-19-PPPCleanArchitecture_ch27/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;택시 통합 서비스를 구현하기 위해 배치된 서비스들&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 시스템을 일년 이상 운영해왔다고 가정한다. 그런데 마케팅 부서와 미팅에서 마케터들은 도시에 야옹이를 배달하는 서비스를 제공한다고 발표한다.&lt;/p&gt;

&lt;p&gt;택시 업체 한곳이 한다고 하였고 참여를 거부하는 업체도 있었다. 당연하지만 고양이 알러지가 있다면 해당 차량은 3일 동안 배차되지 않아야 한다.&lt;/p&gt;

&lt;p&gt;여기서 우리는 어떤 서비스를 고쳐야하는가?? 전부다. 의심의 여지없이 야용이 배달 기능을 추가하려면 개발과 배포 전략을 매우 신중하게 조정해야 한다.&lt;/p&gt;

&lt;p&gt;다시 말해 이 서비스들은 모두 결합되어 있어서 독립적으로 개발하고, 배포하거나, 유지될 수 없다.&lt;/p&gt;

&lt;p&gt;이게 바로 횡단 관심사(cross-cutting concern)가 지닌 문제다. 모든 소프트웨어 시스템은 서비스 지향이든 아니든 이 문제에 직면하게 마련이다.&lt;/p&gt;

&lt;p&gt;위 서비스 다이어그램에서 묘사된 것과 같은 종류의 기능적 분해는 새로운 기능이 기능적 행위를 횡단하는 상황에 매우 취약하다.&lt;/p&gt;

&lt;h2 id=&quot;객체가-구출한다&quot;&gt;객체가 구출한다.&lt;/h2&gt;

&lt;p&gt;컴포넌트 기반 아키텍처에서는 이 문제를 어떻게 해결했을까? SOLID 설계 원칙을 잘 들여다보면, 다형적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 함을 알 수 있다.&lt;/p&gt;

&lt;p&gt;아래의 다이어그램은 이 전략을 보여준다. 배차에 특화된 로직 부분은 Rides 컴포넌트로 추출되고, 야용이에 대한 신규 기능은 Kittens 컴포넌트에 들어간다. 두 컴포넌트는 기존 컴포넌트들에 있는 추상 기반 클래스를 템플릿 메서드(Template Method)나 전략(Strategy) 패턴 등을 이용해서 오버라이드한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-19-PPPCleanArchitecture_ch27/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;객체 지향 방식으로 횡단 관심사를 처리하기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;또한 이 기능들을 구현하는 클래스들은 UI의 제어하에 팩토리(Factories)가 생성한다. 이 전략을 따르더라도 야용이 기능을 구현하려면 TaxiUI는 어쩔 수 없이 변경해야 한다. 하지만 그 외의 것들은 변경할 필요가 없다. 추가만 하면된다.&lt;/p&gt;

&lt;p&gt;따라서 야용이 기능은 결합이 분리되며, 독립적으로 개발하여 배포할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;컴포넌트-기반-서비스&quot;&gt;컴포넌트 기반 서비스&lt;/h2&gt;

&lt;p&gt;이제 당연한 질문은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;서비스에도 이렇게 할 수 있을까?&quot;&lt;/code&gt;다. 물론 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;예&quot;&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;서비스는 SOLID 원칙대로 설계할 수 있으며 컴포넌트 구조를 갖출 수도 있다. 이를 통해 서비스 내의 기존 컴포넌트들을 변경하지 않고도 새로운 컴포넌트를 추가할 수 있다.&lt;/p&gt;

&lt;p&gt;자바의 경우, 서비스를 하나 이상의 jar 파일에 포함되는 추상 클래스들의 집합이라고 생각하라. 새로운 기능 추가 혹은 기능 확장은 새로운 jar 파일로 만든다.그러면 새로운 기능은 재배포하는 문제가 아니라 jar 파일을 추가하는 문제가 된다. 다시 말해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;새로운 기능을 추가하는 행위가 개방 패쇄 원칙을 준수하게 된다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;아래의 서비스 다이어그램은  이 구조를 보여 준다. 서비스들은 이전과 달라진게 없지만 서비스의 내부는 자신만의 컴포넌트 설계로 되어 있어서 파생 클래스를 만드는 방식으로 신규 기능을 추가할 수 잇다. 파생 클래서들은 각자의 컴포넌트 내부에 놓인다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-19-PPPCleanArchitecture_ch27/4.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;각 서비스의 내부는 각자의 방식대로 컴포넌트를 설계할 수 있으며, 파생 클래스를 만들어서 신규 기능을 추가할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;횡단-관심사&quot;&gt;횡단 관심사&lt;/h2&gt;

&lt;p&gt;지금까지 배운 것은 아키텍처 경계가 서비스 사이에 있지 않다는 사실이다.&lt;/p&gt;

&lt;p&gt;오히려 서비스를 관통하며, 서비스를 컴포넌트 단위로 분할한다.&lt;/p&gt;

&lt;p&gt;모든 주요 시스템이 직면하는 횡단 관심사를 처리하려면, 아래의 다이어그램처럼 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다. 이 서비스들은 시스템의 아키텍처 경계를 정의하지 않는다. 아키텍처 경계를 정의하는 것은 서비스 내에 위치한 컴포넌트다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-19-PPPCleanArchitecture_ch27/5.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만, 그 자체로는 아키텍처적으로 그리 중요한 요소는 아니다. 시스템의 아키텍처는 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의 된다. 시스템의 구성 요수고 통신하고 실행되는 물리적인 메커니즘에 의해 아키텍처가 정의되는 것은 아니다.&lt;/p&gt;

&lt;p&gt;서비스는 단 하나의 아키텍처 경계로 둘러싸인 단일 컴포넌트로 만들 수 있다. 혹은 여러 아키텍처 경계로 분리된 다수의 컴포넌트로 구성할 수도 있다.&lt;/p&gt;
</description>
        <pubDate>Thu, 19 May 2022 22:00:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch27/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch27/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>5부 아키텍처</category>
        
      </item>
    
      <item>
        <title>26장. 메인(Main) 컴포넌트</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-19-PPPCleanArchitecture_ch26/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;메인main-컴포넌트&quot;&gt;메인(Main) 컴포넌트&lt;/h1&gt;

&lt;p&gt;모든 시스템에는 최소한 하나의 컴포넌트가 존재하고, 이 컴포넌트가 나머지 컴포넌트를 생성하고, 조정하며 관리한다. 나는 이 컴포넌트를 메인(Main)이라고 부른다.&lt;/p&gt;

&lt;h2 id=&quot;궁극적인-세부사항&quot;&gt;궁극적인 세부사항&lt;/h2&gt;

&lt;p&gt;메인 컴포넌트는 궁극적인 세부사항으로, 가장 낮은 수준의 정책이다. 메인은 시스템의 초기 진입점이다. 운영체제를 제외하면 어떤 것도 메인에 의존하지 않는다.&lt;/p&gt;

&lt;p&gt;의존성을 주입하는 일은 바로 메인 컴포넌트에서 이뤄져야 한다. 메인에 의존성이 일단 주입되고 나면, 메인은 의존성 주입 프레임워크를 사용하지 않고도 일반적인 방식으로 의존성을 분배할 수 있다.&lt;/p&gt;

&lt;p&gt;메인을 가장 지저분한 컴포넌트라고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;아래는 최신 버전의 움퍼스 사냥(Hunt the Wumpus) 게임의 메인 컴포넌트이다. 주목할 부분은 문자열을 로드하는 방법으로, 코드의 나머지 핵심 영역에서 구체적인 문자열을 알지 못하게 하였다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HtwMessageReceiver&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HuntTheWumpus&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hitPoints&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caverns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;environments&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;bright&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;humid&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;dry&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;creepy&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;ugly&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;foggy&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;hot&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;cold&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;drafty&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;dreadful&quot;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shapes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;round&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;square&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;oval&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;irregular&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;long&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;craggy&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;rough&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;tail&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;narrow&quot;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cavernTypes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;cavern&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;room&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;chamber&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;catacomb&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;crevasse&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;cell&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;tunnel&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;passageway&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;hall&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;expanse&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adornments&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;smelling of sulfur&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;with engravings on the walls&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;with a bumpy floor&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;littered with garbage&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;spttered with guano&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;with piles of Wumpus droppings&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;with bones scattered around&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;with a corpse on the floor&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;that seems to vibrate&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;that feels stuffy&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;that fills you with dread&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 main 함수를 보면 HtwFactory를 사용하여 게임을 생성하는 방식을 주목하자. 게임을 생성할 때 htw.game.HunTheWumpusFacase라는 클래스 이름을 전달하는데, 이 클래스는 메인보다도 더 지저분하기 때문이다. 재컴파일/재배포가 되지 않게하기 위함이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HtwFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;makeGame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;htw.game.HuntTheWumpusFacade&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;createMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;BufferedReader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InputStreamReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;makeRestCommand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getPlayerCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Health: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hitPoints&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; arrows: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getQuiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;HuntTheWumpus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Command&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;makeRestCommand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;e&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;makeMoveCommand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EAST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;w&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;makeMoveCommand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;WEST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;n&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;makeMoveCommand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;NORTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;s&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;makeMoveCommand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;SOUTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;r&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;makeRestCommand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sw&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;makeShootCommand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;WEST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;se&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;makeShootCommand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EAST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sn&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;makeShootCommand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;NORTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ss&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;makeShootCommand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;SOUTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;q&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;main 함수에서 주목할 점이 더 있다. 바로 입력 스트림 생성 부분, 게임의 메인 루프 처리, 간단한 입력 명령어 해석 등은 main 함수에서 모두 처리하지만, 명령어를 실제로 처리하는 일은 다른 고수준 컴포넌트로 위임한다는 사실이다.&lt;/p&gt;

&lt;p&gt;마지막으로 지도 생성 역시 main에서 처리한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nCaverns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;30.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;10.0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nCaverns&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;caverns&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;makeName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cavern&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caverns&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;maybeConnectCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;NORTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;maybeConnectCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;SOUTH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;maybeConnectCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;EAST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;maybeConnectCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;WEST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;playerCavern&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;anyCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setPlayerCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;playerCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setWumpusCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;anyOther&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;playerCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addBatCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;anyOther&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;playerCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addBatCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;anyOther&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;playerCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addBatCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;anyOther&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;playerCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addPitCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;anyOther&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;playerCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addPitCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;anyOther&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;playerCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addPitCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;anyOther&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;playerCavern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;game&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setQuiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// 이하 코드 생략&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;요지는 메인은 클린 아키텍처에서 가장 바깥 원에 위치하는, 지저분한 저수준 모듈이다.&lt;/p&gt;

&lt;p&gt;메인은 고수준의 시스템을 위한 모든 것을 로드한 후, 제어권을 고수준의 시스템에게 넘긴다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;
&lt;p&gt;메인은 초기 조건과 설정을 구성하고, 외부 자원을 모두 수집한 후, 제어권을 애플리케이션의 고수준 정책으로 넘기는 플러그인이다. 메인은 플러그인이므로 메인 컴포넌트를 애플리케이션의 설정별로 하나씩 두도록 하여 둘 이상의 메인 컴포넌트를 만들 수도 있다.&lt;/p&gt;

&lt;p&gt;메인은 플러그인 컴포넌트로 여기고, 그래서 아키텍처 경계 바깥에 위치한다고 보면 설정 관련 문제를 훨씬 쉽게 해결할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Thu, 19 May 2022 21:30:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch26/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch26/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>5부 아키텍처</category>
        
      </item>
    
      <item>
        <title>25장. 계층과 경계</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-17-PPPCleanArchitecture_ch25/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;계층과-경계&quot;&gt;계층과 경계&lt;/h1&gt;

&lt;p&gt;시스템이 세 가지 컴포넌트(UI, 업무 규칙, 데이터베이스)로만 구성된다고 생각하기 쉽다. 하지만 대다수의 시스템에서 컴포넌트 개수는 이보다 훨씬 많다.&lt;/p&gt;

&lt;h2 id=&quot;움퍼스-사냥-게임&quot;&gt;움퍼스 사냥 게임&lt;/h2&gt;

&lt;p&gt;1972년에 발매된 인기있는 모험게임인 움퍼스 사냥(Hunt thw Wumpus)는 텍스트를 기반으로 하는 GO EAST와 SHOOT WEST와 같은 매우 단순한 명령어를 사용한다.&lt;/p&gt;

&lt;p&gt;여기서 텍스트 기반 UI는 그대로 유지하되, 게임 규칙과 UI를 분리해서 우리 제품을 여러 시장에서 다양한 언어로 발매할 수 있게 만든다고 가정해 보자. 게임 규칙은 언어 독립적인 API를 사용해서 UI 컴포넌트와 통신할 것이고, UI는 API를 사람이 이해할 수 있는 언어로 변환할 것이다.&lt;/p&gt;

&lt;p&gt;아래의 그림과 같이 의존성을 적절히 관리하면 UI 컴포넌트가 어떤 언어를 사용해도 게임 규칙을 재사용 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-17-PPPCleanArchitecture_ch25/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;UI 컴포넌트가 어떤 언어를 사용하더라도 게임 규칙을 재사용할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;아래의 그림과 같이 의존성 규칙을 준수하여 게임 규칙이 데이터 저장소 컴포넌트와 통신 할 때 우리는 게임 규칙이 다양한 종류의 데이터 저장소에 대해 알지 않기를 원한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-17-PPPCleanArchitecture_ch25/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;의존성 규칙 준수하기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;클린-아키텍처&quot;&gt;클린 아키텍처?&lt;/h2&gt;

&lt;p&gt;위 예제와 같은 단순한 시스템은 클린 아키텍처 접근법을 적용해서 유스케이스, 경계, 엔티티 그리고 관련된 데이터 구조를 모두 만드는 일도 쉬운 일이다. 그런데 정말 아키텍처 경계를 모두 발견한 것인가??&lt;/p&gt;

&lt;p&gt;예를 들어 UI에서 언어가 유일한 변경점은 아니다. 텍스트를 주고 받는 메커니즘을 다양하게 만들고 싶을 수도 있다. 예를 들어 셸(shell)창을 사용하거나 채팅 프로그램으로 할 수도 있다.&lt;/p&gt;

&lt;p&gt;다양한 가능성이 존재하므로 변경의 축에 의해 정의되는 아키텍처 경계가 잠재되어 있을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-17-PPPCleanArchitecture_ch25/4.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;개선된 다이어그램&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;점선으로 된 테두리는 API를 정의하는 추상 컴포넌트를 가리키며, 해당 API는 추상 컴포넌트 위나 아래의 컴포넌트가 구현된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TextDelivery : SMS, Console&lt;/li&gt;
  &lt;li&gt;Language : English, Spanish&lt;/li&gt;
  &lt;li&gt;Data Storage : Cloud Data, Flash Data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 경우에 해당하는 Boundary 인터페이스가 정의하는 API는 의존성 흐름의 상위에 위치한 컴포넌트에 속한다.&lt;/p&gt;

&lt;p&gt;이러한 변형들을 모두 제거하고 순전히 API 컴포넌트만 집중하면 다이어그램을 단순화 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-17-PPPCleanArchitecture_ch25/5.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;단순화된 다이어그램&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 다이어그램은 모든 화살표가 위를 향하도록 맞춰졌다는 점에 주목해야 한다.&lt;/p&gt;

&lt;p&gt;모든 입력은 사용자로부터 전달 받아 TextDelivery를 통해 Language를 거쳐 GameRules에 적합한 명령어로 변역된다.&lt;/p&gt;

&lt;p&gt;GrameRules는 사용자 입력을 처리하고, 우측 하단의 DataStorage로 데이터를 내려 보낸다.&lt;/p&gt;

&lt;p&gt;이 구성은 데이터 흐름을 두 개의 흐름을 효과적으로 분리한다.&lt;/p&gt;

&lt;h2 id=&quot;흐름-횡단하기&quot;&gt;흐름 횡단하기&lt;/h2&gt;

&lt;p&gt;위 예제처럼 데이터 흐름이 항상 두 가지 일까? 절대아니다. 움퍼스 사냥 게임을 네트워크상에서 여러 사람이 함께 플레이할 수 있게 만든다고 해보자&lt;/p&gt;

&lt;p&gt;아래와 같이 네트워크(NETWORK) 컴포넌트를 추가해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-17-PPPCleanArchitecture_ch25/6.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Network 컴포넌트 추가하기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 흐름은 GameRules가 모두 제어한다. 따라서 시스템이 복잡해질수록 컴포넌트 구조는 더 많은 흐름으로 분리될 것이다.&lt;/p&gt;

&lt;h2 id=&quot;흐름-분리하기&quot;&gt;흐름 분리하기&lt;/h2&gt;

&lt;p&gt;이쯤 되면 모든 흐름이 결국에는 상단의 단일 컴포넌트에서 서로 만난다고 생각할 수 있다. 하지만 현실을 훨씬 복잡하다.&lt;/p&gt;

&lt;p&gt;움퍼스 사냥 게임의 GameRules 컴포넌트를 보면 게임 규칙 중일부는 지도와 관련된 메커니즘을 처리한다. 동굴의 연결, 물체의 위치 등을 알고 있다.&lt;/p&gt;

&lt;p&gt;하지만 이보다 더 높은 수준에서 또 다른 정책 집합이 존재한다. 즉, 플레이어 생명령, 사건 해결 비용, 소등 등 이다.&lt;/p&gt;

&lt;p&gt;저수준의 정책은 고수준 정책에게 FellInFit(구덩이에빠짐)과 같은 사건이 발생했음을 알린다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-17-PPPCleanArchitecture_ch25/7.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;고수준의 정책은 플레이어를 관리한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이것이 아키텍처 경계일까? MoveManagement와 PalyerManagement를 분리해야할까? 이 예제를 더 흥미롭게하는 마이크로서비스까지 추가해 보자.&lt;/p&gt;

&lt;p&gt;대규모 플레이어가 동시에 플레이 할 수 있는 버전은 움퍼스 사냥 게임이 있다고 가정해보자. MoveManagement는 플레이어의 컴퓨터에서 처리되지만 PlayerManagement는 서버에서 처리된다.&lt;/p&gt;

&lt;p&gt;PlayerManagement는 접속된 모든 MoveManagement 컴포넌트에 마이크로서비스 API를 제공한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-17-PPPCleanArchitecture_ch25/8.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;마이크로서비스 API 추가하기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MoveManagement와 PlayerManagement 사이에는 완벽한 형테의 아키텍처 경계가 존재한다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;아키텍트로서 우리는 아키텍처 경계가 언제 필요한지를 신중하게 파악해내야 한다. 또한 우리는 이러한 경계를 제대로 구현하려면 비용이 많이 든다는 사실도 인지하고 있어야 한다.&lt;/p&gt;

&lt;p&gt;그러면 우리는 어떻게 해야하나? 매우 똑똑한 사람들이 수년간 말해왔듯이, 우상화가 필요하리라고 미리 예측해서느 안 된다. 이것이 바로 YAGNU(You Aren’t Going to Need It)이 말하는 철학이다. 오버 엔지니어링(over engineering)이 언더 엔지니어링(under engineering)보다 나쁠 때가 훨씬 많기 때문이다.&lt;/p&gt;

&lt;p&gt;우리는 비용을 산정하고 어디에 아키텍처 경계를 둬야 할지, 그리고 완벽하게 구현할 경계는 무엇인지와 부분적으로 구현할 경계와 무시할 경계는 무엇인지를 결정해야 한다.&lt;/p&gt;

&lt;p&gt;하지만 이는 일회성 결정이 아니다. 프로젝트 초반에는 구현할 경계가 무엇인지와 무시할 경계가 무엇인지를 쉽게 결정할 수 없다. 대신 경계가 필요할 수도 있는 부분에 주목하고, 경계가 존재하지 않아 생기는 마찰의 어렴풋한 첫 조짐을 신중하게 관차랳야 한다.&lt;/p&gt;
</description>
        <pubDate>Tue, 17 May 2022 22:50:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch25/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch25/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>5부 아키텍처</category>
        
      </item>
    
      <item>
        <title>24장. 부분적 경계</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-14-PPPCleanArchitecture_ch24/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;부분적-경계&quot;&gt;부분적 경계&lt;/h1&gt;

&lt;p&gt;아키텍처 경계를 완벽하게 만드는 데는 비용이 많이 든다. 엄청난 노력을 기울여야 하고, 유지하는 데도 또 엄청난 노력이 든다.&lt;/p&gt;

&lt;p&gt;많은 경우에, 뛰어난 아키텍트라면 이러한 경계를 만드는게 비용이 너무 많이 든다고 판단하면서도, 나중에 필요할 수도 있으니 경계에 필요한 공간을 확보하기 원할 수 있다.&lt;/p&gt;

&lt;p&gt;애자일 커뮤니티에 속한 사람 중 많은 이가 이러한 종류의 선행적인 설계를 탐탁지 않게 여기는데, YAGNI(You Aren’t Going to Need It) 원칙을 위반하기 때문이다.&lt;/p&gt;

&lt;p&gt;하지만 아키텍트라면 이 문제를 검토하면서 “그래, 하지만 어쩌면 필요할지도.”라는 생각이 든다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부분적 경계(partial boundary)&lt;/code&gt;를 구현해 볼 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;마지막-단계를-건너뛰기&quot;&gt;마지막 단계를 건너뛰기&lt;/h2&gt;

&lt;p&gt;부분적 경계를 생성하는 방법 하나는 독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 것이다.&lt;/p&gt;

&lt;p&gt;아무리 보아도 이처럼 부분적 경계를 만들려면 완벽한 경계를 만들 때만큼 코드량과 사전 설계가 필요하다. 하지만 다수의 컴포넌트 관리하는 작업은 하지 않아도 된다.&lt;/p&gt;

&lt;p&gt;하지만 시간이 흐르면서, 별도로 분리한 컴포넌트가 재사용 될 가능성이 낮아지고 의존성이 잘못된 방향으로 선을 넘기 시작하면 다시 분리하는 작업은 따문한 일이 될 것이다.&lt;/p&gt;

&lt;h2 id=&quot;일차원-경계&quot;&gt;일차원 경계&lt;/h2&gt;

&lt;p&gt;완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 Boundary 인터페이스를 사용한다. 양방향으로 격리된 상태를 유지하려면 초기 설정할 때나 지속적으로 유지할 때도 비용이 많이 든다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 전통적인 전략(Strategy)패턴을 사용하여 추후 완벽한 형태로 경계를 확장하기 위해 공간을 확보할 때 사용 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-14-PPPCleanArchitecture_ch24/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;전략(Strategy) 패턴&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Client를 ServiceImpl로 부터 격리시키는 데 필요한 의존성 역전을 적용하여 미래에 필요한 아키텍처 경계를 만든다.&lt;/p&gt;

&lt;p&gt;하지만 점선 화살표에서 보듯이 이러한 분리는 빠르게 붕괴 될 수 있는데, 쌍방향 인터페이스가 없고 개발자와 아키텍트가 근면 성실하고 제대로 훈련되어 있지 않다면, 이 점선과 같은 비밀 통로가 생기는 일을 막을 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;퍼사드&quot;&gt;퍼사드&lt;/h2&gt;

&lt;p&gt;훨씬 더 단순한 경계는 퍼사드(Facade) 패턴이다. 아래의 그림과 같으며 의존성 역전까지도 희생한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-14-PPPCleanArchitecture_ch24/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;퍼사드(Facade) 패턴&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Facade 클래스에는 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달한다. 클라이언트는 이들 서비스 클래스에 직접 접근 할 수 없다.&lt;/p&gt;

&lt;p&gt;하지만 Client가 이 모든 서비스 클래스에 대해 추이 종속성을 가지게 된다. 정적 언어였다면 서비스 클래스 중 하나에서 소스 코드가 변경되면 Client도 무조건 재컴파일 해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;아키텍처 경계를 부분적으로 구현하는 간단한 방법 세 가지를 살펴봤다.&lt;/p&gt;

&lt;p&gt;접근법 각각은 나름의 비용과 장점을 지닌다. 각 접근법은 완벽한 형태의 경계를 담기 위한 공간으로써, 적절하게 사용할 수 있는 상황이 서로 다르다. 또한 각 접근법은 해당 경계가 실제로 구체화되지 않으면 가치가 떨어질 수 있다.&lt;/p&gt;

&lt;p&gt;아키텍처 경계가 언제, 어디에 존재해야 할지, 그리고 그 경계를 완벽하게 구현할지 아니면 부분저그올 구현할지를 결정하는 일 또한 아키텍트의 역할이다.&lt;/p&gt;

</description>
        <pubDate>Sat, 14 May 2022 18:18:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch24/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch24/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>5부 아키텍처</category>
        
      </item>
    
      <item>
        <title>23장. 프레젠터와 험블 객체</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-14-PPPCleanArchitecture_ch23/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;프레젠터와-험블-객체&quot;&gt;프레젠터와 험블 객체&lt;/h1&gt;

&lt;p&gt;프레젠터는 험블 객체(Humble Object) 패턴을 따른 형태로, 아키텍처 경계를 식별하고 보호하는 데 도움이 된다. 실제로 이전 장 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;클린 아키텍처&quot;&lt;/code&gt;는 험블 객체 구현체들로 가득 차 있다.&lt;/p&gt;

&lt;h2 id=&quot;험블-객체-패턴&quot;&gt;험블 객체 패턴&lt;/h2&gt;

&lt;p&gt;험블 객체 패턴은 디자인 패턴으로 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다.&lt;/p&gt;

&lt;p&gt;아이디어는 매우 단순하다. 행위들을 두 개의 모듈 또는 클래스로 나눈다. 이들 모듈 중 하나가 험블(Humble)이다. 가장 기본적인 본질은 남고, 테스트 하기 어려운 행위를 모두 험블 객체로 옮긴다. 나머지 모듈에는 험블 객체에 속하지 않은 테스트 하기 쉬운 행위를 모두 옮긴다.&lt;/p&gt;

&lt;p&gt;예를 들어 GUI는 테스트하기 어렵다. 하지만 GUI에서 수행하는 행위의 대다수는 쉽게 테스트 할수 있다.&lt;/p&gt;

&lt;p&gt;험블 객체 패턴을 사용하면 두 부류의 행위를 분리하여 프레젠터와 뷰라는 서로 다른 클래스로 만들 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;프레젠터와-뷰&quot;&gt;프레젠터와 뷰&lt;/h2&gt;

&lt;p&gt;뷰는 험블 객체이고 테스트하기 어렵다. 뷰는 데이터를 GUI로 이동시키지만, 데이터를 직접 처리하지는 않는다.&lt;/p&gt;

&lt;p&gt;프레젠터는 테스트하기 쉬운 객체다. 프레젠터의 역할은 애플리케이션으로 부터 데이터를 받아 화면에 표현할 수 있는 포맷으로 만드는 것이다.&lt;/p&gt;

&lt;p&gt;애플리케이션에서 어떤 필드에 날짜를 표시하고자 한다면 프레제터에 Date 객체를 전달하고 프레젠터는 데이터를 적절한 포맷의 문자열로 만든다. 이 문자열은 뷰 모델(view model)이라고 부르는 간단한 데이터 구조를 담는다. 그러면 뷰는 뷰 모델에서 이 데이터를 찾는다.&lt;/p&gt;

&lt;p&gt;뷰는 뷰 모델의 데이터를 화면으로 로드할 뿐이며, 이 외에 뷰가 맡은 역할은 전혀 없다. 따라서 뷰는 보잘것 없다.(humble)&lt;/p&gt;

&lt;h2 id=&quot;테스트와-아키텍처&quot;&gt;테스트와 아키텍처&lt;/h2&gt;

&lt;p&gt;테스트 용이성은 좋은 아키텍처가 지녀야 할 속성으로 오랫동안 알려져 왔다. 험블 객체 패턴이 좋은 예인데, 행위를 테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하면 아키텍처 경계가 정의되기 때문이다. 프레젠터와 뷰 사이의 경계는 이러한 경계 중 하나이다.&lt;/p&gt;

&lt;h2 id=&quot;데이터베이스-게이트웨이&quot;&gt;데이터베이스 게이트웨이&lt;/h2&gt;

&lt;p&gt;유스케이스 인터렉터와 데이터베이스 사이에는 데이터베이스 게이트웨이(Database Gateway)가 위치한다. 이 게이트웨이는 다형적 인테페이스로, 애플리케이션의 데이터베이스에 수행하는 생성, 조회, 갱신, 삭제 작업과 관련된 모든 메서드를 포함한다.&lt;/p&gt;

&lt;p&gt;유스케이스 계층은 필요한 메서드를 제공하는 게이트웨이 인터페이스를 호출한다. 그리고 인터페이스의 구현체는 데이터베이스 계층에 위치한다. 이 구현체는 험블 객체다.&lt;/p&gt;

&lt;p&gt;이와 달리 인터렉터는 애플리케이션에 특화된 업무 규칙을 캡슐화하기 때문에 험블 객체가 아니다. 따라서 테스트하기 쉬운데, 게이트웨이는 스텁(stub)이나 테스트 더블(test-double)로 적당히 교체할 수 있기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;데이터-매퍼&quot;&gt;데이터 매퍼&lt;/h2&gt;

&lt;p&gt;객체 관계 매퍼(Object Relational Mapper, ORM)은 어느 계층인가? 사실 ORM은 존재하지 않는데, 객체는 데이터 구조가 아니기 때문이다.&lt;/p&gt;

&lt;p&gt;데이터는 모두 private으로 선언되므로 객체의 사용자는 데이터를 볼 수 없다.&lt;/p&gt;

&lt;p&gt;객체와 달리 데이터 구조는 함축된 행위를 가지지 않는 public 데이터 변수의 집합이다. ORM 보다는 차라리 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 매퍼(Data Mapper)&lt;/code&gt;라고 부르는 편이 나아 보인다.&lt;/p&gt;

&lt;p&gt;이러한 ORM은 시스템에서 데이터베이스 계층에 속한다. 실제로 ORM은 게이트웨이 인터페이스와 데이터베이스 사이에서 일종의 또 다른 험블 객체 경계를 형성하기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;서비스-리스너&quot;&gt;서비스 리스너&lt;/h2&gt;

&lt;p&gt;애플리케이션이 다른 서비스와 반드시 통신해야 한다면, 또는 애플리케이션에서 일련의 서비스를 제공해야 한다면, 서비스 경계를 생성하는 험블 객체 패턴을 발견 할 수 있다.&lt;/p&gt;

&lt;p&gt;애플리케이션이 데이터를 데이터 구조로 로드하고, 경계를 가로질러 특정 모듈로 전달한다. 해당 모듈은 적절한 포맷으로 변경하여 외부 서비스로 전성한다.&lt;/p&gt;

&lt;p&gt;외부 서비스는 서비스 리스너(service listencer)가 서비스 인터페이스로 부터 데이터를 수신하고, 데이터를 애플리케이션에 사용 할 수 있도록 데이터 구조로 포맷을 변경한다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;각 아키텍처 경계마다 경계 가까이 숨어 있는 험블 객체 패턴을 발견할 수 있다. 경계를 넘나드는 통신은 거의 모두 간단한 데이터 구조를 수반할 때가 많고, 대개 그 경계는 테스트하기 어려운 무언가와 테스트하기 쉬운 무언가로 분리될 것이다.&lt;/p&gt;

&lt;p&gt;그리고 이러한 아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 14 May 2022 15:30:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch23/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch23/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>5부 아키텍처</category>
        
      </item>
    
      <item>
        <title>22장. 클린 아키텍처</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-14-PPPCleanArchitecture_ch22/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;클린-아키텍처&quot;&gt;클린 아키텍처&lt;/h1&gt;

&lt;p&gt;지난 수십 년간 시스템 아키텍처들이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;육각형 아키텍처(Hexagonal Architecture)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;포트와 어댑터(Ports and Adapters)라고도 알려졌으며, 앨리스터 코오빈(Alistair Cockburn)이 개발했다.&lt;/li&gt;
      &lt;li&gt;그리고 스티브 프리먼(Steve Freeman)과 냇 프라이스(Nat Pryce)가 그들의 훌륭한 저서인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;테스트 주도 개발로 배우는 객체지향 설계와 실천&lt;/code&gt;에서 차용했다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DCI(Data, Context and Interaction)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;제임스 코플리언(James Coplien)과 트리그베 린스쿠주(Trygve Reenskaug)가 만들었다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BCE(Boundary-Control-Entity)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;이바 야콥슨이 자신의 저서인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object Oriented Software Engineering&lt;/code&gt;에서 소개했다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이들의 목표는 모두 같은데, 바로 관심사의 분리(separation of converns)다. 이들은 모두 소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성할 수 있었다. 각 아키텍처는 최소한 업무 규칙을 위한 계층하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함한다.&lt;/p&gt;

&lt;p&gt;이들 아키텍처는 시스템에 아래와 같은 특징이 나타나도록 만든다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프레임워크 독립성
    &lt;ul&gt;
      &lt;li&gt;아키텍처는 프레임워크에 존재 여부에 의존하지 않는다. 이를 통해 프레임워크를 도구로 사용하며 프레임워크의 제약사항안으로 시스템을 욱여 넣도록 강제하지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;테스트 용이성
    &lt;ul&gt;
      &lt;li&gt;업무 규칙은 UI, 데이터베이스, 웹 서버, 또는 여타 외부 요소가 없어도 테스트 할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;UI 독립성
    &lt;ul&gt;
      &lt;li&gt;시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터베이스 독립성
    &lt;ul&gt;
      &lt;li&gt;오라클이나 MS SQL서버를 몽고 DB 등으로 교체할 수 있다. 업무 규칙은 데이터베이스에 결합되지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모든 외부 에이전시에 대한 독립성
    &lt;ul&gt;
      &lt;li&gt;실제로 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-14-PPPCleanArchitecture_ch22/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;클린 아키텍처&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;의존성-규칙&quot;&gt;의존성 규칙&lt;/h2&gt;

&lt;p&gt;클린 아키텍처에서 각각의 동심원은 소프트웨어에서 서로 다른 영역을 표현한다. 보통 안으로 들어갈수록 고수준의 소프트웨어가 된다. 바깥쪽 원은 메커니즘이고, 안쪽 원은 정책이다.&lt;/p&gt;

&lt;p&gt;이러한 아키텍처가 동작하도록 하는 가장 중요한 규칙은 의존성 규칙(Dependency Rule)이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;내부의 원에 속한 요소는 외부의 원에 속한 어떤 것도 아지 못한다. 특히 내부의 원에 속한 코드는 외부의 원에 선언된 어떤 것에 대해서도 그 이름을 언급해서는 절대 안된다.&lt;/p&gt;

&lt;p&gt;같은 이유로, 외부의 원에 선언된 데이터 형식도 내부의 원에서 절대로 사용해서는 안 된다. 특히 그 데이터 형식이 외부의 원에 있는 프레임워크가 생성한 것이라면 더더욱 사용해서는 안된다. 우리는 외부 원에 위치한 어떤 것도 내부의 원에 영향을 주지 않기를 바란다.&lt;/p&gt;

&lt;h2 id=&quot;엔티티&quot;&gt;엔티티&lt;/h2&gt;

&lt;p&gt;엔티티는 전사적인 핵심 업무 규칙을 캡슐화 한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;엔티티는 메서드를 가지는 객체이거나 일련의 데이터 구조와 함수의 집합일 수도 있다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;다양한 애플리케이션에서 엔티티를 재사용할 수만 있다면, 그 형태는 그다지 중요하지 않다.&lt;/p&gt;

&lt;p&gt;전사적이지 않은 단순한 단일 애플리케이션을 작성하고 있다면 엔티티는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;해당 애플리케이션의 업무 객체가 된다.&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;특정 어플리케이션에 만 국한되어 있는 엔티티라면 코어가 따로 존재한다는 뜻이 된다. &lt;br /&gt;
전체적으로 관리하는 Core와 각 애플리케이션에서 관리하는 Core&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Core
├─────── Application
├─────── Domain
Service
└─────── Core
          ├──── Application
          ├──── Domain
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;운영 관점에서 특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안 된다.&lt;/p&gt;

&lt;h2 id=&quot;유스케이스&quot;&gt;유스케이스&lt;/h2&gt;

&lt;p&gt;유스케이스 계층의 소프트웨어는ㄴ 애플리케이션에 특화된 업무 규칙을 포함한다. 또한 유스케이스 계층의 소프트웨어는 시스템의 모든 유스케이스를 캡슐화하고 구현한다.&lt;/p&gt;

&lt;p&gt;유스케이스는 엔티티로 들어오고 나가는 데이터 흐름을 조정하며, 엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이의 목적을 달성하도록 이끈다.&lt;/p&gt;

&lt;p&gt;이 계층에서 발생한 변경이 엔티티에 영향을 줘서는 안 된다. 유스케이스 계층은 관심사(DB,UI 등)로부터 격리되어야 한다.&lt;/p&gt;

&lt;p&gt;하지만 운영 관점에서 애플리케이션이 변경된다면 유스케이스가 영향을 받으며, 따라서 이 계층의 소프트웨어에도 영향을 줄 것이다. 유스케이스의 세부사항이 변하면 이 계층의 코드 일부는 분명 영향을 받을 것이다.&lt;/p&gt;

&lt;h2 id=&quot;인터페이스-어댑터&quot;&gt;인터페이스 어댑터&lt;/h2&gt;

&lt;p&gt;인터페이스 어댑터(Interface Adapter) 계층은 일련의 어댑터들로 구성된다. 어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식으로 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환한다.&lt;/p&gt;

&lt;p&gt;프레진터(Presenter), 뷰(View), 컨트롤러(Controller)는 모두 인터페이스 어댑터 계층에 속한다.&lt;/p&gt;

&lt;p&gt;모델은 그저 데이터 구조 정도에 지나지 않으며, 컨트롤러에서 유스케이스로 전달되고, 다시 유스케이스에서 프레젠터와 뷰로 되돌아 간다.&lt;/p&gt;

&lt;p&gt;마찬가지로 이 계층은 데이터를 엔티티와 유스케이스에게 가장 편리한 형식에서 영속성용으로 사용 중인 임의으이 프레임워크(즉, 데이터베이스)가 이용하기에 가장 편리한 형식으로 변환한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이 원 안에 속한 어떤 코드도 데이터베이스에 대해 알아서는 안된다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이 계층에는 데이터를 외부 서비스와 같은 외부적인 형식에서 유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또 다른 어댑터가 필요하다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;인터페이스 어댑터 계층은 Usecase만 사용하지 DB가 어떤 건지는 관련하지 않는다. &lt;br /&gt;
인터페이스만 사용한다는 것이고 구현체가 무엇인지는 중요하지 않다. 데이터만 잘 가져오면 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;프레임워크-드라이버&quot;&gt;프레임워크 드라이버&lt;/h2&gt;

&lt;p&gt;아키텍처에서 가장 바깥쪽 계층은 일반적으로 데이터베이스나 웹 프레임워크 같은 프레임워크나 도구들로 구성된다. 일반적으로 이 계층에서는 안쪽원과 통신하기 위한 접합 코드 외에는 특별히 더 작성해야 할 코드가 그다지 많지 않다.&lt;/p&gt;

&lt;p&gt;프레임워크와 드라이버 계층은 모든 세부사항이 위치하는 곳이다. 웹은 세부사항이다. 데이터베이스는 세부사항이다.&lt;/p&gt;

&lt;p&gt;우리는 이러한 것들을 모두 외부에 위치시켜서 피해를 최소화해야한다.&lt;/p&gt;

&lt;h2 id=&quot;원은-네-개여야만-하나&quot;&gt;원은 네 개여야만 하나?&lt;/h2&gt;
&lt;p&gt;네 개보다 더 많은 원이 필요할 수도 있다. 항상 네개만 사용해야 한다는 규칙은 없다. 하지만 어떤 경우에도 의존성 규칙은 적용된다.&lt;/p&gt;

&lt;p&gt;소스코드 의존성은 항상 안쪽으로 향한다. 안쪽으로 이동할수도록 추상화와 정책의 수준은 높아진다. 가장 바깥쪽 원은 저수준의 구체적인 세부사항으로 구성된다.&lt;/p&gt;

&lt;h2 id=&quot;경계-횡단하기&quot;&gt;경계 횡단하기&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-14-PPPCleanArchitecture_ch22/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;경계 횡단하기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;아키텍처의 우측하단 다이어그램에 원의 경계를 횡단하는 방법을 보여주는 예시가 있다. 이 예시에서 컨트롤러와 프레젠터가 다음 계층에 속한 유스케이스와 통신하는 모습을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;제어흐름은 컨트롤러로 시작해서, 유스케이스를 지난 후, 프레젠터에서 실행되면서 마무리된다. 각 의존성은 유스케이스를 향해 안쪽을 가리킨다&lt;/p&gt;

&lt;p&gt;이처럼 제어흐름과 의존성의 방향이 명백히 반대여야 하는 경우, 대체로 의존성 역전 원칙을 사용해 해결한다.&lt;/p&gt;

&lt;p&gt;우리는 동적 다형성을 이용하여 소스 코드 의존성을 제어흐름과는 반대로 만들수 있고, 이를 통해 제어흐름이 어느 방향으로 흐르더라도 의존성 규칙을 준수할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;경계를-횡단하는-데이터는-어떤-모습인가&quot;&gt;경계를 횡단하는 데이터는 어떤 모습인가??&lt;/h2&gt;

&lt;p&gt;경계를 가로지르는 데이터는 흥히 간단한 데이터 구조로 이루어져 있다. 기본적인 구조체나 간단한 데이터 전송 객체(data transfer object) 등 원하는 대로 고를 수 있다. 또는 함수를 호출할 때 간단한 인자를 사용해서 데이터로 전달할 수도 있다.&lt;/p&gt;

&lt;p&gt;중요한 점은 격리되어 있는 간단한 데이터 구조가 경계를 가로질러 전달된다는 사실이다. 꾀를 부려서 엔티티 객체나 데이터베이스의 행(row)을 전달하는 일은 원치 않는다. 우리는 데이터 구조가 어떤 의존성을 가져 의존성 규칙을 위배하게 되는 일은 바라지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;전형적인-시나리오&quot;&gt;전형적인 시나리오&lt;/h2&gt;

&lt;p&gt;아래의 다이어 그램은 데이터베이스를 사용하는 웹 기반 자바 시스템의 전형적인 시나리오이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-14-PPPCleanArchitecture_ch22/4.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;데이터베이스를 사용하는, 웹 기반 자바 시스템의 전형적인 시나리오&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;웹 서버가 사용자로부터 입력 데이터를 모아 좌측 상단의 Controller로 전달한다. Controller는 데이터를 자바 객체(POJO)로 묶은 후, InputBoundary 인터페이스를 통해 UseCaseInteractor로 전달하고 UseCaseInteractor는 데이터를 해석하여 Entities를 어떻게 사용할지 제어하는 데 사용한다.&lt;/p&gt;

&lt;p&gt;Presentoer는 OutputData를 ViewModel과 같이 화면에 출력 할 수 있느 형식으로 재구성하는 일이다. View는 이 데이터를 화면에 출력한다.&lt;/p&gt;

&lt;p&gt;의존성의 방향에 주목해야 한다. 모든 의존성은 경계선을 안쪽으로 가로지르며, 따라서 의존성 규칙을 준수한다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;이상의 간단한 규칙들을 준수하는 일은 어렵지 않으며, 향후에 겪을 수많은 고통거리를 덜어줄 것이다. 소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며, 그에 따른 이점을 누릴 수 있다.&lt;/p&gt;

</description>
        <pubDate>Sat, 14 May 2022 15:00:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch22/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch22/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>5부 아키텍처</category>
        
      </item>
    
      <item>
        <title>21장. 소리치는 아키텍처</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-13-PPPCleanArchitecture_ch21/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;소리치는-아키텍처&quot;&gt;소리치는 아키텍처&lt;/h1&gt;

&lt;p&gt;건물의 청사진을 살펴보고 있다고 상상해보자. 아키텍트가 작성한 건물에 대한 일련의 계획을 보여주고 있다.&lt;/p&gt;

&lt;p&gt;계획서가 사람이 거주 할 주택이라면 정문, 거실로 연결되는 현관, 그리고 부엌 가족방 등이 있을 가능성이 높다. 이러한 계획서를 보면 이건 한 가족이 사는 주택이라는 느낌을 받을 것이다. 다시 말해, 아키텍처가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;난 집이야!!&lt;/code&gt;라고 소리칠 것이다.&lt;/p&gt;

&lt;p&gt;자, 여러분의 애플리케이션 아키텍처는 뭐라고 소리치는가? 상위 수준의 디렉터리 구조, 최상위 패키지에 담긴 소스 파일을 볼 때, 이 아키텍처는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;헬스케어 시스템이야!&quot;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;재고 관리 시스템이야!&quot;&lt;/code&gt;라고 소리치는가??&lt;/p&gt;

&lt;p&gt;아니면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;스프링이야!&quot;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;ASP야!!&quot;&lt;/code&gt;라고 소리치는가??&lt;/p&gt;

&lt;h2 id=&quot;아키텍처의-테마&quot;&gt;아키텍처의 테마&lt;/h2&gt;

&lt;p&gt;이바 야콥슨(Ivar Jacobson)이 쓴 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Object Oriented Software Engineering&lt;/code&gt;이라는 책의 부제가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유스케이스 주도 접근법(Use Case Driven Approach)&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;야콥슨은 소프트웨어 아키텍처는 시스템의 유스케이스를 지원하는 구조라고 지적했다. 주택이나 도서관의 계획서가 해당 건축물의 유스케이스에 대해 소리치는 것처럼, 소프트웨어 애플리케이션의 아키텍처도 애플리케이션의 유스케이스에 대해 소리쳐야 한다.&lt;/p&gt;

&lt;p&gt;아키텍처는 프레임워크에 대한 것이 아니다. 아키텍처를 프레임워크로부터 제공받아서는 절대 안 된다.&lt;/p&gt;

&lt;p&gt;아키텍처를 프레임워크 중심으로 만들어버리면 유스케이스가 중심이 되는 아키텍처는 절대 나올 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;아키텍처의-목적&quot;&gt;아키텍처의 목적&lt;/h2&gt;

&lt;p&gt;좋은 아키텍처는 유스케이스를 그 중심에 두기 때문에, 프레임워크나 도구, 환경에 전혀 구애받지 않고 유스케이스를 지원하는 구조를 아무런 문제 없이 기술할 수 있다.&lt;/p&gt;

&lt;p&gt;좋은 소프트웨어 아키텍처는 프레임워크, 데이터베이스, 웹 서버, 그리고 여타 개발 환경 문제나 도구에 대해서는 결정을 미룰 수 있도록 만든다.&lt;/p&gt;

&lt;p&gt;좋은 아키텍처는 유스케이스에 중점을 두며, 지엽적인 관심사에 대한 결합은 분리시킨다.&lt;/p&gt;

&lt;h2 id=&quot;하지만-웹은&quot;&gt;하지만 웹은??&lt;/h2&gt;

&lt;p&gt;웹은 아키텍처일까?? 시스템이 웹을 통해 전달된다는 사실이 시스템의 아키텍처에 영향을 주는가? 당연히 아니다! 웹은 전달 메커니즘(입출력 장치)이며, 애플리케이션 아키텍처에서도 그와 같이 다뤄야 한다.&lt;/p&gt;

&lt;p&gt;실제 애플리케이션을 웹으로 전달할지 여부는 미루어야 할 결정사항 중 하나다. 시스템 아키텍처는 시스템이 어떻게 전다로딜지에 대해 가능하다면 아무것도 몰라야 한다.&lt;/p&gt;

&lt;p&gt;시스템을 콘솔 앱, 웹 앱, 리크 클라이언트 앱, 심지어 웹서비스 앱으로도 전달할 수 있어야 한다.&lt;/p&gt;

&lt;h2 id=&quot;프레임워크는-도구일-뿐-삶의-방식은-아니다&quot;&gt;프레임워크는 도구일 뿐, 삶의 방식은 아니다.&lt;/h2&gt;

&lt;p&gt;프레임워크는 매우 강력하고 상당히 유용할 수 있다. 프레임워크 제작자는 자신이 만든 프레임워크를 매우 깊이 신뢰하곤 한다. 프레임워크를 사용하는 방식을 보여주면서, 흔히 모든 것을 아우르는, 어디에나 스며드는, “프레임워크가 모든 것을 하게하자”라는 태도를 취한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이는 우리가 취하고 싶은 태도가 아니다&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;어떻게 하면 아키텍처를 유스케이스에 중점을 둔 채 그대로 보전할 수 있을지를 생각하라. 프레임워크는 아키텍처의 중심을 차지하는 일을 막을 수 있는 전략을 개발하라.&lt;/p&gt;

&lt;h2 id=&quot;테스트하기-쉬운-아키텍처&quot;&gt;테스트하기 쉬운 아키텍처&lt;/h2&gt;

&lt;p&gt;아키텍처가 유스케이스를 최우선으로 한다면, 그리고 프레임워크와는 적당한 거리를 둔다면, 프레임워크를 전혀 준비하지 않더라도 필요한 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;테스트를 돌리는 데 웹 서버가 반드시 필요한 상황이 되어서는 안 된다. 데이터베이스가 반드시 연결되어 있어야만 테스트를 돌리 수 잇어서도 안 된다.&lt;/p&gt;

&lt;p&gt;엔티티 객체는 반드시 오래 된 방식의 간단한 객체(plain old object)여야 하며, 프레임워크나 데이터베이스, 또는 여타 복잡한 것들에 의존해서는 안 된다.&lt;/p&gt;

&lt;p&gt;최종적으로, 프레임워크로 인한 어려움을 겪지 않고도 반드시 이 모두를 있는 그대로 테스트 할 수 있어야 한다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;아키텍처는 시스템을 이야기해야 하며, 시스템에 적용한 프레임워크에 대해 이야기해서는 안 된다.&lt;/p&gt;

&lt;p&gt;새로 합류한 프로그래머는 시스템이 어떻게 전달될지 알지 못한 상태에서도 시스템의 모든 유스케이스를 이해할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;언젠가 이들은 당신을 찾아와서 이렇게 말할 것이다.&lt;/p&gt;

&lt;p&gt;“모델처럼 보이는 것들을 확인했습니다. 그런데 뷰와 컨트롤러는 어디에 있죠?”&lt;/p&gt;

&lt;p&gt;그러면 당신은 이와 같이 답해야 한다.&lt;/p&gt;

&lt;p&gt;“아, 그것은 세부사항이므로 당장슨 고려할 필요가 없습니다. 나중에 결정 할 겁니다.”&lt;/p&gt;
</description>
        <pubDate>Fri, 13 May 2022 23:30:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch21/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch21/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>5부 아키텍처</category>
        
      </item>
    
      <item>
        <title>20장. 업무 규칙</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-13-PPPCleanArchitecture_ch20/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;업무-규칙&quot;&gt;업무 규칙&lt;/h1&gt;
&lt;p&gt;애플리케이션을 업무 규칙과 플러그인으로 구분하려면 업무 규칙이 실제로 무엇인지를 잘 이해해야만 한다.&lt;/p&gt;

&lt;p&gt;엄밀하게 말하면 업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차다. 더 엄밀하게 말하면 컴퓨터상으로 구현했는지와 상관없이, 업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;대출에 N% 이자를 부과한다는 사실은 은행이 돈을 버는 업무 규칙이다. 이건 사람이든 컴퓨터 프로그램이는 하등 관계가 없다.&lt;/p&gt;

&lt;p&gt;이러한 규칙을 핵심 업무 규칙(Critical Business Rule)이라고 부를 것이다. 이들 규칙은 사업 자체의 핵심적이며, 규칙을 자동화하는 시스템이 없더라도 업무 규칙은 그대로 존재하기 때문이다.&lt;/p&gt;

&lt;p&gt;핵심 규칙과 핵심 데이터는 본질적으로 결합되어 있기 때문에 객체로 만들 좋은 후보가 된다. 우리는 이러한 유형의 객체를 엔티티(Entity)라고 하겠다.&lt;/p&gt;

&lt;h2 id=&quot;엔티티&quot;&gt;엔티티&lt;/h2&gt;

&lt;p&gt;엔티티는 컴퓨터 시스템 내부의 객체로서, 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화한다. 엔티티 객체는 핵심 업무 데이터를 직접 포함하거나 핵심 업무 데이터에 매우 쉽게 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;인티티의 인터페이스는 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성된다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 대출을 뜻하는 Loan 엔티티가 UML 클래스로 어떻게 표현되는지 보여준다. 세 가지 핵심 업무 데이터를 포함하며, 데이터와 관련된 세 가지 핵심 업무 규칙을 인터페이스로 제공한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;classDiagram
    class Loan{
        - principle
        - rate
        - period
        + makePayment()
        + applyInterest()
        + chargeLateFee()
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;UML 클래스로 표현한 Loan 엔티티&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이  클래스는 업무의 대표자로서 독립적으로 존재한다. 이 클래스는 데이터베이스, 사용자 인터페이스, 서드파티 프레임워크에 대한 고려사항들로 인해 오염되어서는 절대 안 된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;엔티티는 순전히 업무에 대한 것이며, 이외의 것은 없다.&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;유스케이스&quot;&gt;유스케이스&lt;/h2&gt;

&lt;p&gt;모든 업무 규칙이 엔티티처럼 순수한 것은 아니다. 자동화된 시스템이 동작하는 방법을 정의하고 제약함으로써 수익을 얻거나 비용을 줄이는 업무 규칙도 존재한다.&lt;/p&gt;

&lt;p&gt;유스케이스는 자동화된 시스템이 사용되는 방법을 설명한다. 유스케이스는 사용자가 제공하는 입력, 사용자에게 보여줄 출력, 그리고 해당 출력을 생성하기 위한 처리 단계를 기술한다.&lt;/p&gt;

&lt;p&gt;엔티티 내의 핵심 업무 규칙과는 반대로, 유스케이스는 애플리케이션에 특화된(application-specific) 업무 규칙을 설명한다.&lt;/p&gt;

&lt;p&gt;유스케이스는 엔티티 내부의 핵심 업무 규칙을 어떻게 그리고 언제 호출할지를 명시하는 규칙을 담는다.&lt;/p&gt;

&lt;p&gt;주목할 또 다른 사실은 인터페이스로 들어오는 데이터와 인터페이스에서 되돌려주는 데이터를 형식 없이 명시한다는 점만 빼면, 유스케이스는 사용자 인터페이스를 기술하지 않는다는 점이다. 유스케이스만 봐서는 애플리케이션이 웹을 통해 전달되는지, 리치 클라이언트인지, 콘솔인지 구분하기란 불가능하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-13-PPPCleanArchitecture_ch20/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;유스케이스 예제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;유스케이스는 시스템이 사용자에게 어떻게 보이는지를 설명하지 않는다. 이보다는 애플리케이션에 특화된 규칙을 설명하며, 이를 통해 사용자와 엔티티 사이의 상호작용을 규정한다. 시스템에서 데이터가 들어오고 나가는 방식은 유스케이스와는 무관하다.&lt;/p&gt;

&lt;p&gt;유스케이스는 객체다. 유스케이스는 애플리케이션에 특화된 업무 규칙을 구현하는 하나 이상의 함수를 제공한다. 또한 유스케이스는 입력 데이터, 출력 데이터, 유스케이스가 상호작용하는 엔티티에 대한 참조 데이터 등의 데이터 요소를 포함한다.&lt;/p&gt;

&lt;p&gt;왜 엔티티는 고수준이며, 유스케이스는 저수준일까? 왜냐하면 유스케이스는 단일 애플리케이션에 특화되어 있으며, 따라서 해당 시스템의 입력과 출력에 보다 가깝게 위치하기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;요청-및-응답-모델&quot;&gt;요청 및 응답 모델&lt;/h2&gt;

&lt;p&gt;유스케이스는 입력 데이터를 받아서 출력 데이터를 생성한다. 제대로 구성된 유스케이스 객체라면 데이터를 사용자나 또 다른 컴포넌트와 주고 받는 방식에 대해서는 전혀 눈치챌 수 없어야 한다.&lt;/p&gt;

&lt;p&gt;데이터 구조는 HttpRequest나 HttpResponse 같은 표준 프레임 워크 인터페이스로부터 파생되지 않는다. 웹뿐만 아니라 그 어떤 사용자 인터페이스에도 종속되는 게 아무것도 없다.&lt;/p&gt;

&lt;p&gt;이 처럼 의존성을 제거하는 일은 매우 중요하다. 요청 및 응답 모델이 독립적이지 않다면, 그 모델에 의존하는 유스케이스도 결국 해당 모델이 수반하는 의존성에 간접적으로 결합되어 버린다.&lt;/p&gt;

&lt;p&gt;엔티티와 요청/응답 모델은 상당히 많은 데이터를 공유하므로 엔티티를 요청/응답 모델에 참조를 걸고 싶은 유혹을 받을 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 두 객체의 목적은 완전히 다르며 시간이 지나면 두 객체는 완전히 다른 이유로 변경될 것이고, 따라서 두 객체를 어떻 식으로든 함께 묶는 행위는 공통 폐쇄 원칙과 단일 책임 원칙을 위배하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;업무 규칙은 소프트웨어 시스템이 존재하는 이유다. 업무 규칙은 핵심적인 기능이다.&lt;/p&gt;

&lt;p&gt;업무 규칙은 사용자 인터페이스나 데이터베이스와 같은 저수준의 관심사로 인해 오염되어서는 안 되며, 원래 그대로의 모습으로 남아 있어야 한다.&lt;/p&gt;

&lt;p&gt;업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드여야 한다.&lt;/p&gt;
</description>
        <pubDate>Fri, 13 May 2022 22:50:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch20/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch20/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>5부 아키텍처</category>
        
      </item>
    
      <item>
        <title>19장. 정책과 수준</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-13-PPPCleanArchitecture_ch19/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;정책과-수준&quot;&gt;정책과 수준&lt;/h1&gt;

&lt;p&gt;소프트웨어 시스템이란 정책을 기술한 것이다. 컴퓨터 프로그램은 각 입력을 출력으로 변환하는 정책을 상세하게 기술한 설명서다.&lt;/p&gt;

&lt;p&gt;대다수의 주요 시스템에서 하나의 정책은 이 정책을 서술하는 여러 개의 조그만 정책들로 쪼갤 수 있다.&lt;/p&gt;

&lt;p&gt;소프트웨어 아키텍처를 개발하는 기술에는 이러한 정책을 신중하게 분리하고, 정책이 변경되는 양상에 따라 정책을 재편성하는 일도 포함된다. 동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준에 위치하며, 동일한 컴포넌트에 속해야 한다. 서로 다른 이유로, 혹은 다른 시점에 변겨오디는 정책은 다른 수준에 위치하며, 반드시 다른 컴포넌트로 분리해야 한다.&lt;/p&gt;

&lt;p&gt;흔히 아키텍처 개발은 재편성된 컴포넌트들을 비순환 방향 그래프(directed acyclic graph)로 구성하는 기술을 포함한다. 그래프에서 정점(node)은 동일한 수준의 정책을 포함하는 컴포넌트에 해당한다. 방향이 있는 간선(edge)은 컴포넌트 사이의 의존성을 나타낸다. 간선은 다른 수준에 위치한 컴포넌트를 서로 연결한다.&lt;/p&gt;

&lt;p&gt;이러한 의존성은 소스 코드, 컴파일타임의 의존성이다. 자바의 import, C#의 using 구문이다. 이러한 의존성은 컴파일러가 제대로 동작하기 위해서 필요하다.&lt;/p&gt;

&lt;p&gt;좋은 아키텍처라면 각 컴포넌트를 연결할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 한다. 즉, 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계되어야 한다.&lt;/p&gt;

&lt;h2 id=&quot;수준&quot;&gt;수준&lt;/h2&gt;

&lt;p&gt;수준(level)을 엄밀하게 정의하자면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;입력과 출력까지의 거리&lt;/code&gt;다. 시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다. 입력과 출력을 다루는 정책이라면 시스템에서 최하위 수준에 위치한다.&lt;/p&gt;

&lt;p&gt;아래의 데이터흐름도는 간단한 암호화 프로그램이다. 데이터의 흐름은 굽은 실선 화살표, 소스 코드 의존성은 곧은 점선으로 표시되어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-13-PPPCleanArchitecture_ch19/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;간단한 암호화 프로그램&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;번역 컴포넌트는 최고 수준의 컴포넌트인데, 입력과 출력에서부터 가장 멀리 떨어져 있기 때문이다.&lt;/p&gt;

&lt;p&gt;주목할 점은 데이터 흐름과 소스 코드 의존성이 항상 같은 방향을 가리키지 않는다는 사실이다. 다시 한번 말하지만 이것이 바로 소프트웨어 아키텍처가 가진 예술 중하나다. 소스 코드 의존성은 그 수준에 따라 결합되어야 하며, 데이터 흐름을 기준으로 결합되어서는 안 된다.&lt;/p&gt;

&lt;p&gt;자칫하면 잘못된 아키텍처가 만들어지는데, 예를 들어 암호화 프로그램을 다음처럼 작성한다면 그렇게 된다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;fuction&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;encrypt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;writeChar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;translate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readChar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()));&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;고수준인 encrypt 함수가 저수준인 readChar와 writeChar 함수에 의존하기 때문이다.&lt;/p&gt;

&lt;p&gt;아래의 클래스 다이어그램은 개선해본 모습니다. Encrypt 클래스, CharWriter와 CharReader 인터페이스를 둘러싸고 있는 점선으로 된 경계다. 이 경계를 횡단하는 의존성은 모두 경계 안쪽으로 향한다. 이 경계로 묶인 영역이 이 시스템에서 최고 수준의 구성요소다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-13-PPPCleanArchitecture_ch19/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;시스템의 더 나은 아키텍처를 보여주는 클래스 다이어그램&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;정책을 컴포넌트로 묶는 기준은 정책이 변경되는 방식에 달려있다는 사실을 상기하자. 단일 책임 원칙(SRP)과 공통 폐쇄 원칙(CCP)에 따르면 동일한 이유로 동일한 시점에 변경되는 정책은 함께 묶인다.&lt;/p&gt;

&lt;p&gt;고수준 정책, 즉 입력과 출력에서부터 멀리 떨어진 정책은 저수준 정책에 비해 덜 빈번하게 변경되고, 보다 중요한 이유로 변경되는 경향이 있다. 저수준 정책, 즉 입력과 출력에 가까이 위치한 정책은 더 빈번하게 변경되며, 보다 긴급성을 요하며, 덜 중요한 이유로 변경되는 경향이 있다.&lt;/p&gt;

&lt;p&gt;모든 소스코드 의존성의 방향이 고수준 정책을 향할 수 있도록 정책을 분리했다면 변경의 영향도 줄일 수 있다. 시스템의 최저 수준에서 중요하지 않지만 긴급한 변경이 발생하더라도, 보다 높은 위치의 중요한 수준에 미치는 영향은 거의 없게 된다.&lt;/p&gt;

&lt;p&gt;이 논의는 저수준 컴포넌트가 고수준 컴포넌트에 플러그인되어야 한다는 관점에서 바라볼 수도 있다. Encryption 컴포넌트는 IO Devices 컴포넌트를 전혀 알지 못한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-13-PPPCleanArchitecture_ch19/4.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;저수준 컴포넌트는 고수준 컴포넌트에 플러그인되어야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;정책에 대한 논의는 단일 책임 원칙, 개발 폐쇄 원칙, 공통 폐쇄 원칙, 의존성 역전 원칙, 안정된 의존성 원칙, 안정된 추상화 원칙을 모두 포함한다.&lt;/p&gt;

&lt;p&gt;이 원칙들의 설명을 다시 읽어 보며 각 원칙이 어디에서 무슨 이유로 사용되었는지를 찾아보자.&lt;/p&gt;
</description>
        <pubDate>Fri, 13 May 2022 22:00:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch19/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch19/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>5부 아키텍처</category>
        
      </item>
    
      <item>
        <title>18장. 경계 해부학</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-13-PPPCleanArchitecture_ch18/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;경계-해부학&quot;&gt;경계 해부학&lt;/h1&gt;

&lt;p&gt;시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의 된다.&lt;/p&gt;

&lt;p&gt;이번 장에서는 경계의 다양한 형태를 알아본다.&lt;/p&gt;

&lt;h2 id=&quot;경계-횡단하기&quot;&gt;경계 횡단하기&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;런타임에 경계를 횡단한다&lt;/code&gt;함은 그저 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일에 불과하다.&lt;/p&gt;

&lt;p&gt;적절한 위치에서 경계를 횡당하게 하는 비결은 소스 코드 의존성 관리에 있다.&lt;/p&gt;

&lt;p&gt;소스 코드 모듈이 변경되면 의존되는 다른 소스 코드도 다시 컴파일하고 배포해야 한다.&lt;/p&gt;

&lt;p&gt;경계는 이러한 변경이 전파 되는 것을 막는 방화벽을 구축하고 관리하는 수단으로써 존재한다.&lt;/p&gt;

&lt;h2 id=&quot;두려운-단일체&quot;&gt;두려운 단일체&lt;/h2&gt;

&lt;p&gt;아키텍처 경계 중에서 가장 단순하며 가장 흔한 형태는 물리적으로 엄격하게 구분되지 않는 형태다.&lt;/p&gt;

&lt;p&gt;이 형태에서는 함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며 그저 나름의 규칙에 따라 분리되어 있을 뿐이다. 이전 장에서는 나는 이를 소스 수준 분리 모드라고 불렀다.&lt;/p&gt;

&lt;p&gt;배포 관점에서는 소위 단일체(monolith)라고 불리는 단일 실행 파일에 지나지 않는다. 배포 관점에서 볼 때 단일체는 경계가 드러나지 않는다.&lt;/p&gt;

&lt;p&gt;가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다. 이 경우 런타임 의존성과 컴파일타임 의존성은 모두 같은 방향, 즉, 저수준 컴포넌트에서 고수준 컴포넌트로 향한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-13-PPPCleanArchitecture_ch18/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;제어흐름은 경계를 횡단할 때 저수준에서 고수준으로 향한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;고수준 클라이언트가 저수준 서비스를 호출해야 한다면 동적 다형성을 사용하여 제어흐름과는 반대 방향으로 의존성을 역전시킬 수 있다. 이렇게 하면 런타임 의존성은 컴파일타임 의존성과는 반대가 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-13-PPPCleanArchitecture_ch18/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;제어흐름은 반대로 경계를 횡단한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;정적 링크된 모노리틱 구조의 실행 파일이라도 이처럼 규칙적인 방식으로 구조를 분리하면 프로젝트를 개발, 테스트, 배포하는 작업에 큰 도움이 된다.&lt;/p&gt;

&lt;p&gt;팀들은 서로의 영역에 침범하지 않은 채 자신만의 컴포넌트를 독립적으로 작업할 수 있다. 고수준 컴포넌트는 저수준 세부사항으로부터 독립적으로 유지된다.&lt;/p&gt;

&lt;h2 id=&quot;배포형-컴포넌트&quot;&gt;배포형 컴포넌트&lt;/h2&gt;

&lt;p&gt;아키텍처의 경계가 물리적으로 드러날 수도 있는데 그중 가장 단순한 형태는 동적 링크 라이브러리다. .NET DLL, 자바 jar파일 등이 그예이다.&lt;/p&gt;

&lt;p&gt;단일체와 마찬가지로 배포형 컴포넌트의 경계를 가로지르는 통신은 순전히 함수 호출에 지나지 않으므로 매우 값싸다. 동적 링크와 런타임 로디으로 인해 최초의 함수 호출은 오래 걸릴 수도 있지만, 이들 경계를 가로지르는 통신은 매우 빈번할 것이다.&lt;/p&gt;

&lt;h2 id=&quot;스레드&quot;&gt;스레드&lt;/h2&gt;

&lt;p&gt;단일체와 배포형 컴포넌트는 모두 스레드를 활용할 수 있다. 스레드는 아키텍처 경계도 아니며 배포 단위도 아니다. 이보다 스레드는 실행 계획과 순서를 체계화하는 방법에 가깝다. 모든 스레드가 단 하나의 컴포넌트에 포함될 수도 있고, 많은 컴포넌트에 걸쳐 분산될 수도 있다.&lt;/p&gt;

&lt;h2 id=&quot;로컬-프로세스&quot;&gt;로컬 프로세스&lt;/h2&gt;

&lt;p&gt;훨씬 강한 물리적 형태를 띠는 아키텍처 경계로는 로컬 프로세스가 있다. 로컬 프로세스는 주로 명령행이나 그와 유사한 시스템 호출을 통해 생성 된다.&lt;/p&gt;

&lt;p&gt;각 로컬 프로세스는 정적으로 링크된 단일체이거나 동적으로 링크된 여러개의 컴포넌트로 구성될 수 있다. 전자의 경우, 여러 모노리틱 프로세스가 같은 컴포넌트들을 가지고 있을 수 있다.(컴파일하고 정적 링크하는 과정에서 각 컴포넌트의 바이너리가 단일체에 물리적으로 복사되어 들어가기 때문이다.). 반면 후자의 경우, 동적 링크된 배포형 컴포넌트들을 서로 공유할 수 있다.&lt;/p&gt;

&lt;p&gt;로컬 프로세스를 일정의 최상위 컴포넌트라고 생각하자. 즉, 로컬 프로세스는 컴포넌트 간 의존성을 동적 다형성을 통해 관리하는 저수준 컴포넌트로 구성된다.&lt;/p&gt;

&lt;p&gt;로컬 프로세스 간 분리 전략은 단일체나 바이너리 컴포넌트의 경우와 동일하다. 소스 코드 의존성의 화살표는 단일체나 바이너리 컴포넌트와 동일한 방향으로 경계를 횡단한다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;항상 고수준 컴포넌트를 향한다.&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;서비스&quot;&gt;서비스&lt;/h2&gt;

&lt;p&gt;물리적인 형태를 띠는 가장 강력한 경계는 바로 서비스다. 서비스는 프로세스로, 일반적으로 명령행 또는 그와 동등한 시스템 호출을 통해 구동된다.&lt;/p&gt;

&lt;p&gt;서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느리다. 가능하다면 빈번하게 통신하는 일을 피해야 한다. 이 수준의 통신에서는 지연(latency)에 따른 문제를 고수준에서 처리할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;저수준 서비스는 반드시 고수준 서비스에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;플러그인&lt;/code&gt;되어야 한다. 고수준 서비스의 소스 코드에는 저수준 서비스를 특정 짓는 어떤 물리적인 정보(예를 들면 URI)도 포함해서느 ㄴ안된다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다. 서비스 경계를 활용하는 시스템이라면 로컬 프로세스 경계도 일부 포함하고 있을 수 있다. 실제로 서비스는 상호작용하는 일련의 로컬 프로세스 퍼사드(Facade)에 불과할 때가 많다. 또한 개별 서비스 또는 로컬 프로세스는 거의 언제나 소스 코드 컴포넌트로 구성된 단일체이거나, 혹은 동적으로 링크된 배포형 컴포넌트의 집합니다.&lt;/p&gt;

&lt;p&gt;즉, 대체로 한 시스템 안에서도 통신이 빈번한 로컬 경계와 지연을 중요하게 고려해야 하는 경계가 혼합되어 있음을 의미한다.&lt;/p&gt;
</description>
        <pubDate>Fri, 13 May 2022 21:00:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch18/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch18/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>5부 아키텍처</category>
        
      </item>
    
      <item>
        <title>17장. 경계,선긋기</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-10-PPPCleanArchitecture_ch17/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;경계-선-긋기&quot;&gt;경계: 선 긋기&lt;/h1&gt;

&lt;p&gt;소프트웨어 아키텍처는 선을 긎는 기술이며, 나는 이러한 선을 경계(boundary)라고 부른다.&lt;/p&gt;

&lt;p&gt;경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막는다.&lt;/p&gt;

&lt;p&gt;프로젝트 초기에 그어진 선은 가능한 오랫동아 결정을 연기시키기 위해, 그래서 이들 결정이 핵심적인 업무 로직을 오염시키지 못하도록 만들려는 목적으로 쓰인다.&lt;/p&gt;

&lt;p&gt;아키텍트의 목표는 인적 자원을 최소화하는 것이다. 인적 자원의 효율을 떨어뜨리는 요인은 바로 결합(coupling)이다. 특히 너무 일찍 내려진 결정에 따른 결합이다.&lt;/p&gt;

&lt;p&gt;이러한 결정은 시스템의 업무 요구사항, 즉 유스케이스와 아무런 관련이 없는 결정이다. 프레임워크, 데이터베이스, 웹 서버, 유틸리티 라이브러리, 의존성 주입에 대한 결정들이 포함된다.&lt;/p&gt;

&lt;p&gt;좋은 시스템 아키텍처는 이러한 결정을 가능한 한 최후의 순간에 내릴 수 있게 해주며, 결정에 따른 영향이 크지 않게 만든다.&lt;/p&gt;

&lt;h2 id=&quot;두-가지-슬픈-이야기&quot;&gt;두 가지 슬픈 이야기&lt;/h2&gt;

&lt;h3 id=&quot;p사의-슬플-이야기&quot;&gt;P사의 슬플 이야기&lt;/h3&gt;

&lt;p&gt;먼저 P 회사의 슬픈 이야기는 1990년대 데스크톱 GUI 애플리케이션으로 성장했다. 하지만 웹이 대세가 되면서 자바 프로그래머를 다수 고용 했고, 자사 제품을 웹 버전으로 변환하는 프로젝트에 착수 했다.&lt;/p&gt;

&lt;p&gt;자바 진영 사람은 머릿속에 서버 팜(server farm)이 춤추는 이상을 꿈꾸었기에, 3-티어로 구성된 리치(rish) 아키텍처를 채택했고, 서버 팜을 통해 분산하고자 했다.&lt;/p&gt;

&lt;p&gt;서버 팜에는 GUI를 위한 서버, 미들웨어 서버, 데이터베이스 서버가 있었다. 이들 프로그래머는 모든 도메인 객체가 세 가지 인스턴스를 가져야 한다고 너무 이른 결정을 내렸다.&lt;/p&gt;

&lt;p&gt;하나는 GUI 티어를 위해, 또 하나는 미들웨어 티어를 위해, 나머지 하나는 데이터베이스 티어를 위해서이다.&lt;/p&gt;

&lt;p&gt;이들 인스턴스는 서로 다른 머신에 상주했기 때문에 티어 간 메서드 호출은 객체로 변환하여, 직렬화 한 후, 회선을 통해 마샬링(marshalling) 되었다.&lt;/p&gt;

&lt;p&gt;역설적이게도 P사는 서버 팜을 필요로 하는 시스템을 한번도 판매하지 못했다. 배포했던 시스템은 모두 단일 서버였다. 그리고 단일 서버에서 세 실행 파일은 객체 초기화, 직렬화, 마샬링과 언마샬링, 메시지 구성과 파싱, 소켓 통신들과 추가 작업들을 지속했다.&lt;/p&gt;

&lt;p&gt;P사의 실수는 아키텍트가 너무 이르게 결정을 내림으로써 개발 비용을 엄청나게 가중시킨 사례다.&lt;/p&gt;

&lt;h3 id=&quot;w사의-슬픈-이야기&quot;&gt;W사의 슬픈 이야기&lt;/h3&gt;

&lt;p&gt;일련의 회사 차량을 관리하는 지역 기업인 W사를 살펴보자. 이들은 최근 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;아키텍트&lt;/code&gt;를 고용하였고, 그는 모든 특성이 구성된 엔터프라이즈급의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서비스 지향 아키텍처&lt;/code&gt;가 필요하다는 것을 파악했다.&lt;/p&gt;

&lt;p&gt;업무와 관련된 서로 다른 모든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;객체&lt;/code&gt;들로 구성된 거대한 도메인 모델을 생성했고, 이들 도메인 객체를 관리하기 위해 서비스들의 묶음을 설계했으며, 모든 개발자를 지옥의 길로 밀어 넣었다.&lt;/p&gt;

&lt;p&gt;당연하겠지만 무언가를 테스트하려면 필요한 서비스들을 하나씩 구동시키고 메시지 버스와 BPel(Business Process Execution Language)서버 등을 작동시켜야 했다.&lt;/p&gt;

&lt;p&gt;이들 모든 서비스 사이의 결합으로 인해 엄청난 양의 WSDL(Web Services Description Language)를 변경해야하며, 변경에 영향받는 모든 것을 다시 배포해야 할 것이다.&lt;/p&gt;

&lt;p&gt;W사의 실수는 SOA를 약속하는 일련의 도구들을 너무 일찍 채택하여 적용했다는 사실이다.&lt;/p&gt;

&lt;h2 id=&quot;fitnesse&quot;&gt;FitNesse&lt;/h2&gt;

&lt;p&gt;나는 2001년에 FitNesse를 만들기로 하였다. 이때는 메이븐이 등장하여 jar 파일 문제를 해결하기 전이였다.&lt;/p&gt;

&lt;p&gt;우리가 초기에 내린 결정 중 하나는 FitNesse의 요구에 특화된 우리만의 웹서버를 직접 작성하자는 것이였다. 기본 뼈대만 갖춘 웹 서버는 단일 소프트웨어이기에 구현이 간단하고 어떤 웹 프로그램워크를 사용할지에 대한 결정을 훨씬 나중으로 연기할 수 있었다.&lt;/p&gt;

&lt;p&gt;초기에 내린 또 다른 결정은 데이터베이스에 대해 고민하지 말자는 것이였다. 어떤 데이터베이스를 사용하더라도 상관 없도록 설계하여 의도적으로 데이터베이스에 대한 결정을 미뤘다. 우리는 모든 데이터 접근 영역과 데이터 저장소 영역 사이에 인터페이스를 추가하는 간단한 설계 방식을 사용했다.&lt;/p&gt;

&lt;p&gt;자그마치 18개월 동안 데이터베이스가 없다는 사실은 스키마와 관련된 문제들, 쿼리 문제들, 데이터베이스 서버 문제들, 패스워드 문제들 그리고 데이터베이스를 작동시킬 때 추하게 고개를 드는 여타 모든 고약한 문제가 없었다는 사실을 뜻한다.&lt;/p&gt;

&lt;p&gt;테스트를 느리게 만드는 데이터베이스가 없으니 테스트 또한 빠르게 돌릴 수 있었다.&lt;/p&gt;

&lt;p&gt;간단히 말해서 경계선을 긋는 행위는 결정을 늦추고 연기하는 데 도움이 되었고, 궁극적으로는 시간을 엄청나게 절약해주었으며, 골치를 썩지 않게해주었다.&lt;/p&gt;

&lt;h2 id=&quot;어떻게-선을-그을까-그리고-언제-그을까&quot;&gt;어떻게 선을 그을까? 그리고 언제 그을까?&lt;/h2&gt;

&lt;p&gt;관련이 있는 것과 없는 것 사이에 선을 긋는다. GUI는 업무 규칙과는 관련 없기 때문에, 이 둘 사이에는 반드시 선이 있어야 한다.&lt;/p&gt;

&lt;p&gt;데이터베이스는 GUI와는 관련이 없으므로, 이 둘 사이에도 반드시 선이 있어야 한다.&lt;/p&gt;

&lt;p&gt;데이터 베이스는 업무 규칙과 관련 없으므로, 이 둘 사이에도 선이 있어야 한다.&lt;/p&gt;

&lt;p&gt;데이터베이스는 업무 규칙이 간접적으로 사용할 수 있는 도구다. 업무 규칙은 스키마, 쿼리 언어, 또는 데이터베이스와 관련된 나머지 세부사항에 대해 어떤 것도 알아서는 안된다.&lt;/p&gt;

&lt;p&gt;아래의 그림에서 보면 BusinessRules는 Database Interface를 사용하여 데이터를 로드하고 저장한다. DatabaseAccess는 DatabaseInterface를 구현하며, Database를 실제로 자작하는 일을 맡는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-10-PPPCleanArchitecture_ch17/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;인터페이스 뒤로 숨은 데이터베이스&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;경계선은 어디에 있는가? 경계선은 상속 관계를 횡단하면서 Database Interface 바로 아래에 그어진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-10-PPPCleanArchitecture_ch17/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;경계선&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이제 조금 물러 나서 많은 업무 규칙이 포함된 컴포넌트, 데이터베이스와 데이터베이스 접근 클래스를 포함하는 컴포넌트를 살펴본다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-10-PPPCleanArchitecture_ch17/4.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;업무 규칙과 데이터베이스 컴포넌트&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Database는 BusinessRules에 대해 알고 있다. BusinessRules는 Database에 관해 알지 못한다. 이는 DatabaseInterface 클래스는 BusinessRules 컴포넌트에 속하며, DatabaseAccess 클래스는 Database 컴포넌트에 속한다는 사실을 의미한다.&lt;/p&gt;

&lt;p&gt;Database 컴포넌트는 다양한 구현체로 교체될 수 있으며, BusinessRules는 조금도 개의치 않는다.&lt;/p&gt;

&lt;p&gt;이 같은 사실은 데이터베이스에 대한 결정은 연기할 수 있으며, 데이터베이스를 결정하기에 앞서 업무 규칙을 먼저 작성하고 테스트하는 데 집중 할 수 있음을 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;입력과-출력은&quot;&gt;입력과 출력은?&lt;/h2&gt;

&lt;p&gt;개발자와 고객은 종종 시스템이 무엇인지에 대해 혼란스러워한다. GUI를 보고선 GUI가 시스템이라고 생각하곤한다.&lt;/p&gt;

&lt;p&gt;우리는 시스템의 행위를 입출력이 지닌 행위적 측면에서 생각하는 경향이 있다. 예를 들어 비디오게임에서 사용자 경험은 인터페이스에 의해 좌우된다. 화면, 마우스, 버튼, 음향이 바로 그 인터페이스다.&lt;/p&gt;

&lt;p&gt;이러한 인터페이스 뒤에는 인터페이스를 조작하는 모델(데이터 구조와 함수로 구성된 정교한 집합)이 존재한다는 사실을 잊어버린다.
더 중요한 사실은 모델은 인터페이스가 필요하지 않다. 화면에 출력되지 않아도 돌아가는데 문제가 없다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;중요한 것은 업무 규칙이다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-10-PPPCleanArchitecture_ch17/5.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;GUI와 BusinessRules 컴포넌트 사이의 경계&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;GUI와 BusinessRules 컴포넌트가 경계선에 의해 분할된다는 사실을 알 수 있다. GUI는 다른 종류의 인터페이스로 얼마든지 교체할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;플러그인-아키텍처&quot;&gt;플러그인 아키텍처&lt;/h2&gt;

&lt;p&gt;데이터베이스와 GUI에 대해 내린 두 가지 결정을 하나로 합쳐서 보면 컴포넌트 추가와 관련한 일종의 패턴이 만들어진다. 이 패턴은 시스템에서 서드 파티 플러그인을 사용할 수 있게 한 바로 그 패턴과 동일하다.&lt;/p&gt;

&lt;p&gt;사실 소프트웨어 개발 기술의 역사는 플러그인을 손쉽게 생성하여, 확장 가능하며 유지보수가 쉬운 시스템 아키텍처를 확립할 수 있게 만드는 방법에 대한 이야기다.&lt;/p&gt;

&lt;p&gt;선택적이거나 또는 수많은 다양한 형태로 구현될 수 있는 나머지 컴포넌트로부터 핵심적인 업무 규칙은 불리되어 있고, 또한 독립적이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-10-PPPCleanArchitecture_ch17/6.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;업무 규칙에 플러그인 형태로 연결하기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 설계에서 사용자 인터페이스는 플러그인 형태로 고려되었기에, 수많은 종류의 사용자 인터페이스를 플러그인 형태로 연결할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;교체 작업은 사소한 것이 아닐 것이다. 시스템의 초기 배포본이 웹 기반이었다면 클라이언트-서버 UI용 플러그인을 작성하는 것은 쉽지 않은 일이 될 수 있다.&lt;/p&gt;

&lt;p&gt;그러다 하더라도 플러그인 구조를 가정할 채 시작함으로써, 최소한 우리는 이러한 변경 작업을 현실성 있도록 만들었다.&lt;/p&gt;

&lt;h2 id=&quot;플러그인에-대한-논의&quot;&gt;플러그인에 대한 논의&lt;/h2&gt;

&lt;p&gt;ReSharper와 비주얼 스튜디오(Visual Studio)의 관계를 보자. 어느 팀이 다른 팀을 위험하게 만들 수 있을까? &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;의존성 구조가 답해준다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-10-PPPCleanArchitecture_ch17/7.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;ReSharper는 비주얼 스튜디오에 의존한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ReSharper는 비주얼 스튜디오의 소스 코드에 의존하기 때문에 비주얼 스튜디오 팀은 원한다면 언제든지 ReSharper팀을 완전히 무력화할 수 있다.&lt;/p&gt;

&lt;p&gt;우리는 시스템에서 한 부분이 변경되더라도 관련 없는 나머지 부분이 망가지길 원치 않는다.&lt;/p&gt;

&lt;p&gt;경계는 변경의 축(axis of change)이 있는 지점에 그어진다. 경계의 한쪽에 위치한 컴포넌트는 경계 반대편의 컴포넌트와는 다른 속도로, 그리고 다른 이유로 변경된다.&lt;/p&gt;

&lt;p&gt;업무 규칙은 의존성 주입 프레임워크와는 다른 시점에 그리고 다른 이유로 변경되므로, 둘 사이에도 반드시 경계가 필요하다.&lt;/p&gt;

&lt;p&gt;이 역시도 순전히 단일 책임 원칙에 해당한다. 단일 책임 원칙은 어디에 경계를 그어야 할지를 알려준다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야 한다. 일부 컴포넌트는 핵심 업무 규칙에 해당한다.&lt;/p&gt;

&lt;p&gt;이는 의존성 역전 원칙과 안정된 추상화 원칙을 응용한 것임을 눈치챌 수 있어야 한다. 의존성 화살표는 저수준 세부사항에서 고수준의 추상화를 향하도록 배칳야 한다.&lt;/p&gt;
</description>
        <pubDate>Tue, 10 May 2022 22:00:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch17/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch17/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>5부 아키텍처</category>
        
      </item>
    
      <item>
        <title>16장. 독립성</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch16/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;독립성&quot;&gt;독립성&lt;/h1&gt;

&lt;p&gt;좋은 아키텍처는 다음을 지원해야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시스템의 유스케이스&lt;/li&gt;
  &lt;li&gt;시스템의 운영&lt;/li&gt;
  &lt;li&gt;시스템의 개발&lt;/li&gt;
  &lt;li&gt;시스템의 배포&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;유스케이스&quot;&gt;유스케이스&lt;/h2&gt;

&lt;p&gt;첫 번째 주요 항목인 유스케이스의 경우, 시스템의 아키텍처는 시스템의 의도를 지원해야 한다는 뜻이다.&lt;/p&gt;

&lt;p&gt;아키텍트의 최우선 관심사는 유스케이스이며, 아키텍처에서도 유스케이스가 최우선이다. 아키텍처는 반드시 유스케이스를 지원해야 한다.&lt;/p&gt;

&lt;p&gt;좋은 아키텍처가 행위를 지원하기 위해 할 수 있는  중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.&lt;/p&gt;

&lt;p&gt;장바구니 애플리케이션이 좋은 아키텍처를 갖춘다면 이 애플리케이션은 장바구니 애플리케이션처럼 보일 것이다. 해당 시스템의 유스케이스는 시스템 구조 자체에서 한눈 에 들어날 것이다.&lt;/p&gt;

&lt;p&gt;이들 행위는 일급 요소(first-class)이며 시스템의 최상위 수준에서 알아볼 수 있으므로, 개발자가 일일이 찾아 헤매지 않아도 된다.&lt;/p&gt;

&lt;h2 id=&quot;운영&quot;&gt;운영&lt;/h2&gt;

&lt;p&gt;시스템의 운영 지원 관점에서 볼 때 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡는다. 아키텍처는 요구와 관련 된 각 유스케이스에 걸맞은 처리량와 응답시간을 보장해야 한다.&lt;/p&gt;

&lt;p&gt;이러한 형태를 지원한다는 말은 시스템에 따라 다양한 의미를 지닌다. 어떤 시스템에서는 시스템의 처리 요소를 일련의 작은 서비스들로 배열하여 서로 다른 많은 서버에서 병렬로 실행할 수 있게 만들어야 함을 의미한다.&lt;/p&gt;

&lt;p&gt;만약 시스템이 단일체(monolith)로 작성되어 모노리틱 구조를 갖는다면, 다중 프로세스, 다중 스레드, 또는 마이크로서비스 형태가 필요해질 때 개선하기 어렵다.&lt;/p&gt;

&lt;p&gt;그에 비해 아키텍처에서 각 컴포넌트를 적걸히 격리하고 유지하고 컴포넌트 간 통신 방싱을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.&lt;/p&gt;

&lt;h2 id=&quot;개발&quot;&gt;개발&lt;/h2&gt;

&lt;p&gt;아키텍처는 개발환경을 지원하는 데 있어 핵심적인 역할을 수행한다.&lt;/p&gt;

&lt;p&gt;콘웨이(Conway)의 법칙이 작용하는 지점이 바로 여기이다. 코누에이의 법칙은 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;많은 팀으로 구성되며 관심사가 다양한 조직에서 어떤 시스템을 개발해야 한다면, 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 팀들이 서로를 방해하지 않도록 해야한다.&lt;/p&gt;

&lt;p&gt;이러한 아키텍처를 만들려면 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할 할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;그래야만 이들 컴포넌트를 독립적으로 작업할 수 있는 팀에 할당할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;배포&quot;&gt;배포&lt;/h2&gt;

&lt;p&gt;아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 한다. 이때 목표는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;즉각적인 배포(immediate deployment)&lt;/code&gt;다.&lt;/p&gt;

&lt;p&gt;좋은 아키텍처는 수십 개의 작은 설정 스크립트나 속성 파일을 약간씩 수정하는 방식을 사용하지 않는다.&lt;/p&gt;

&lt;p&gt;좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.
‘다시 말하지만, 이러한 아키텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다.&lt;/p&gt;

&lt;h2 id=&quot;선태사항-열어놓기&quot;&gt;선태사항 열어놓기&lt;/h2&gt;

&lt;p&gt;좋은 아키텍처는 컴포넌트 구조와 관련된 이 관심사들 사이에서 균형을 맞추고, 각 관심사 모두를 만족시킨다.&lt;/p&gt;

&lt;p&gt;말은 쉽지만 현실에서는 이러한 균형을 잡기가 매우 러렵다. 대부분의 경우 우리는 모든 유스케이스를 알 수는 없으며, 운영하는 데 따르는 제약사항, 팀 구조, 배포 요구사항도 알지 못하기 때문이다.&lt;/p&gt;

&lt;p&gt;더 심각한 문제는 이러한 사항들을 알고 있더라도, 시스템이 생명주기의 단계를 하나씩 거쳐감에 따라 이 사항들도 반드시 변해간다는 사실이다.&lt;/p&gt;

&lt;p&gt;하지만 몇몇 아키텍처 원칙을 구현하는 비용은 비교적 싸지 않으며, 관심사들 사이에서 균형을 잡는데 도움이 된다. 이들 원칙은 시스템을 제대로 격리된 컴포넌트 단위로 분할 할 때 도움이 되며, 이를 통해 선택사항을 가능한 한 많이, 그리고 가능한한 오랫동안 열어 둘 수 있게 해준다.&lt;/p&gt;

&lt;p&gt;좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.&lt;/p&gt;

&lt;h2 id=&quot;계층-결합-분리&quot;&gt;계층 결합 분리&lt;/h2&gt;

&lt;p&gt;아키텍트는 필요한 모든 유스케이스를 지원할 수 있는 시스템 구조를 원하지만, 유스케이스 전부를 알지는 못한다.&lt;/p&gt;

&lt;p&gt;하지만 아키텍트는 시스템의 기본적인 의도는 분명히 알고 있다. 그 시스템이 장바구니 시스템인지, 자재 명세서 시스템인지 안다는 뜻이다.&lt;/p&gt;

&lt;p&gt;따라서 아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여, 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들은 묶는다.&lt;/p&gt;

&lt;p&gt;사용자 인터페이스가 변경되는 이유는 업무 규칙과는 아무런 관련이 없다. 만약 유스케이스가 두 가지 요소를 모두 포함한다면, 유스케이스에서 UI 부분와 업무 규칙 부분을 서로 분리하고자 할 것이다.&lt;/p&gt;

&lt;p&gt;업무 규칙은 그 자체가 애플리케이션과 밀접한 관련이 있거나, 혹은 더 범용적일 수 있다. 예를 들어 입력 필드 유효성 검사는 애플리케이션 자체와 연관 된 업무 규칙이다.&lt;/p&gt;

&lt;p&gt;반대로 계좌의 이자 계산 같은 경우는 업무 도메인에 더 밀접하게 연관된 엄무 규칙이다.&lt;/p&gt;

&lt;p&gt;이들 규칙은 서로 분리하고, 독립적으로 변경할 수 있도록 만들어야만 한다.&lt;/p&gt;

&lt;p&gt;데이터베이스, 쿼리 언어, 스키마 조차도 업무 규칙이나 UI와는 아무런 관련이 없다. 결론적으로 아키텍트는 이들을 시스템의 나머지 부분으로부터 분리하여 독립적으로 변경할 수 있도록 해야만 한다.&lt;/p&gt;

&lt;p&gt;이제 우리는 서로 결합되지 않은 수평적인 계층으로 분리하는 방법을 알게 되었다.&lt;/p&gt;

&lt;p&gt;이러한 계층의 예로는 UI, 애플리케이션에 특화된 업무 규칙, 애플리케이션과는 독립적인 업무 규칙, 데이터베이스 등을 들 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;유스케이스-결합-분리&quot;&gt;유스케이스 결합 분리&lt;/h2&gt;

&lt;p&gt;서로 다른 이유로 변경되는 것에는 또 무엇이 있을까? 바로 유스케이스 그 자체가 있다!&lt;/p&gt;

&lt;p&gt;주문 입력시스템에서 주문을 추가하는 유스케이스는 주문을 삭제하는 유스케이스와는 틀림없이 다른 속도로, 그리고 다른 이유로 변경된다. 유스케이스는 시스템을 분할하는 매우 자연스러운 방법이다.&lt;/p&gt;

&lt;p&gt;이와 같이 결합을 분리하려면 주문 추가 유스케이스의 UI와 주문 삭제 유스케이스의 UI를 분리해야 한다. 이런식으로 시스템의 맨 아래 계층까지 수직으로 내려가며 유스케이스들이 각 계층에서 서로 겹치지 않게 한다.&lt;/p&gt;

&lt;p&gt;여기에서 패턴을 볼 수 있다. 시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있다.&lt;/p&gt;

&lt;p&gt;유스케이스가 UI와 데이터베이스의 서로 다른 관점(aspect)를 사용하게 되면, 새로운 유스케이스를 추가하더라도 기존 유스케이스에 영향을 주는 일은 거의 없을 것이다.&lt;/p&gt;

&lt;h2 id=&quot;결합-분리-모드&quot;&gt;결합 분리 모드&lt;/h2&gt;

&lt;p&gt;이렇게 결합을 분리하면 두 번째 항목인 운영 관점에서 어떤 의미가 있는지 살펴본다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch16/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;수직, 수평 계층 분할 예시&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;UI와 데이터베이스가 업무 규칙과 분리되어 있다면, UI와 데이터베이스는 업무 규칙과는 다른 서버에서 실행될 수 있다. 높은 대역폭을 요구사흔ㄴ 유스케이스는 여러 서버로 복제하여 실행할 수 있따.&lt;/p&gt;

&lt;p&gt;분리된 컴포넌트를 서로 다른 서버에서 실행해야 하는 상황이라면, 이들 컴포넌트가 단일 프로세서의 동일한 주소 공간에 함께 상주하는 형태가 만들어져서는 안 된다.&lt;/p&gt;

&lt;p&gt;분리된 컴포넌트는 반드시 독립된 서비스가 되어야 하고, 일정의 네트워크를 통해 서로 통신해야 한다.&lt;/p&gt;

&lt;p&gt;많은 아키텍트가 이러한 컴포넌트를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서비스(service)&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;마이크로서비스(micro-service)&lt;/code&gt;라고 하는데, 실제로 서비스에 기반한 아키텍처를 흔히들 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서비스 지향 아키텍처(service-oriented architecture)&lt;/code&gt;라고 부른다.&lt;/p&gt;

&lt;p&gt;여기서 이야기 하고자 하는 핵심은 우리는 때때로 컴포넌트를 서비스 수준까지도 분리해야 한다는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;개발-독립성&quot;&gt;개발 독립성&lt;/h2&gt;

&lt;p&gt;컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다. 업무 규칙이 UI를 알지 못하면 UI에 중점을 둔 팀은 업무 규칙에 중점을 둔 팀에 그다지 영향을 줄 수 없다.&lt;/p&gt;

&lt;p&gt;기능팀, 컴포넌트 팀, 계층 팀, 혹은 또 다른 형태의 팀이라도, 계층과 유스케이스의 결합이 분리되는 한 시스템의 아키텍처는 그 팀 구조를 뒷받침해 줄 것이다.&lt;/p&gt;

&lt;h2 id=&quot;배포-독립성&quot;&gt;배포 독립성&lt;/h2&gt;

&lt;p&gt;유스케이스와 계층의 결합이 분리되면 배포 측면에서도 고도의 유연성이 생긴다. 실제로 결합을 제대로 분리했다면 운영 중인 시스템에서도 계층과 유스케이스를 교체(hot-swap) 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;중복&quot;&gt;중복&lt;/h2&gt;

&lt;p&gt;소프트웨엉에서 중복은 일반적으로 나쁜 것이다. 우리는 중복된 코드를 좋아하지 않는다. 코드가 진짜로 중복되었다면, 우리는 전문가로서의 명예를 걸고 중복을 줄이거나 제거해야 한다.&lt;/p&gt;

&lt;p&gt;하지만 중복에도 종류가 있다. 그 중하나는 진짜 중복이다. 이 경우는 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야 한다.&lt;/p&gt;

&lt;p&gt;또 다른 중복은 거짓된 또는 우발적 중복이다. 중복으로 보이지만 두 코드 영역이 각자의 경로로 발전한다면, 즉 서로 다른 속도와 다른 이유로 변경된다면 이 두 코드는 진짜 중복이 아니다.&lt;/p&gt;

&lt;p&gt;유스케이스를 수직으로 분리할 때 이러한 문제와 마주칠 테고, 이들 유스케이를 통합하고 싶다는 유혹을 받게 될 것이다. 하지만 조심해야 한다. 중복이 진짜 중복인지 확인해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;결합-분리-모드다시&quot;&gt;결합 분리 모드(다시)&lt;/h2&gt;

&lt;p&gt;다시 결합 분리 모드로 돌아간다. 계층과 유스케이스의 결합을 분리하는 방법은 다양하다.&lt;/p&gt;

&lt;h3 id=&quot;소스-수준-분리-모드&quot;&gt;소스 수준 분리 모드&lt;/h3&gt;

&lt;p&gt;소스 코드 모듈 사이의 의존성을 제어할 수 있다. 이를 통해 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 만들 수 있다(예, 루비 Gem).&lt;/p&gt;

&lt;p&gt;이 모드에서는 모든 컴포넌트가 같은 주소 공간에서 실행되고 서로 통신할 때는 간단한 함수 호출을 사용한다.&lt;/p&gt;

&lt;p&gt;이러한 구조를 모노리틱 구조라고 부른다.&lt;/p&gt;

&lt;h3 id=&quot;배포-수준-분리-모드&quot;&gt;배포 수준 분리 모드&lt;/h3&gt;

&lt;p&gt;jar 파일, DLL, 공유 라이브러리와 같은 배포 가능한 단위들 사이의 의존성을 제어할 수 있다. 이를 통해 한 모듈의 소스 코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있다.&lt;/p&gt;

&lt;p&gt;이 모드의 중요한 특징은 결합이 분리된 컴포넌트가 jar 파일, Gem 파일, DLL과 같이 독립적으로 배포할 수 있는 단위로 분할되어 있다는 점이다.&lt;/p&gt;

&lt;h3 id=&quot;서비스-수준-분리-모드&quot;&gt;서비스 수준 분리 모드&lt;/h3&gt;

&lt;p&gt;의존하는 수준을 데이터 구조 단위 까지 낮출 수 있고, 순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있다.&lt;/p&gt;

&lt;p&gt;이를 통해 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적이게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;시간이 흐르면 시스템에서 운영 요구사항은 감소할 수 있다. 한때는 결합을 서비스 수준까지 분리해야 했던 것들이 이제 배포 수준, 심지어 소스 수준의 결합 분리만으로 충분할 수도 있다.&lt;/p&gt;

&lt;p&gt;좋은 아키텍처는 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도, 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성정하고, 또 독립적인 서비스나 마이크로서비스 수준까지 성정할 수 있도록 만들어져야한다.&lt;/p&gt;

&lt;p&gt;또한 좋은 아키텍처라면 나중에 상황이 바뀌었을 때 이 진행 방향을 거꾸로 돌려 원래 형태인 모노리틱 구조로 되돌리 수도 있어야 한다.&lt;/p&gt;

&lt;p&gt;좋은 아키텍처는 이러한 변경으로부터 소스 코드 대부분을 보호한다. 좋은 아키텍처는 결합 분리 모드를 선택사항으로 남겨두어서 배포 규모에 따라 가장 적합한 모드를 선택해 사용할 수 있게 만들어 준다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;물론 이렇게 하기느 ㄴ까다롭다. 그리고 결합 분리 모드를 변경하기가 설정 값하나 바꾸듯 쉬워야 한다는 뜻이 아니다.&lt;/p&gt;

&lt;p&gt;시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 뛰어나 아키텍트라면 이러한 변경을 예층하여 큰 무리 없이 반영할 수 있도록 만들어야 한다는 점이다.&lt;/p&gt;
</description>
        <pubDate>Sun, 08 May 2022 21:00:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch16/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch16/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>5부 아키텍처</category>
        
      </item>
    
      <item>
        <title>15장. 아키텍처란?</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch15/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;아키텍처란&quot;&gt;아키텍처란?&lt;/h1&gt;

&lt;p&gt;아키텍처(architecture)라는 단어는 권력과 신비로움을 연상케 한다. 소프트웨어아키텍처는 기술적 성취의 정점에 서 있다. 소프트웨어 아키텍트를 생각할 때면, 권한을 가지며 존경심을 불러일으키는 사람을 떠올린다.&lt;/p&gt;

&lt;p&gt;그러면 소프트웨어 아키텍처란 무엇인가? 소프트웨어 아키텍트는 무슨 일을 하며, 언제 그 일을 하는가?&lt;/p&gt;

&lt;p&gt;무엇보다도 소프트웨어 아키텍트는 프로그래머이며, 앞으로도 계속 프로그래머로 남는다. 소프트웨어 아키텍트라면 코드에서 탈피하고 고수준의 문제에 집중해야 한다는 거짓말에 절대로 속아서는 안된다.&lt;/p&gt;

&lt;p&gt;소프트웨어 아키텍트는 최고의 프로그래머이며, 앞으로도 계속 프로그래밍 작업을 맡을 뿐만 아니라 동시에 나머지 팀원들이 생산성을 극대화할 수 있는 설계를 하도록 방향을 이끌어 준다.&lt;/p&gt;

&lt;p&gt;소프트웨어 시스템의 아키텍처란 시스템을 구축했던 사람들이 만들어낸 시스템의 형태이다. 그 모양은 시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에 따라 정해진다.&lt;/p&gt;

&lt;p&gt;그리고 그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수 되도록 만들어진다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이러한 일을 용이하게 만들기 위해서는 가능한 한 많은 선택지를, 가능한 한 오래 남겨두는 전략을 따라야 한다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다. 좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 또 쉽게 배포하게 해준다.&lt;/p&gt;

&lt;p&gt;아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.&lt;/p&gt;

&lt;h2 id=&quot;개발&quot;&gt;개발&lt;/h2&gt;

&lt;p&gt;개발하기 힘든 시스템이라면 수명이 길지도 않고 건강하지도 않을 것이다.&lt;/p&gt;

&lt;p&gt;시스템 아키텍처는 개발팀(들)이 시스템을 쉽게 개발할 수 있도록 뒷바침해야한다.&lt;/p&gt;

&lt;p&gt;팀 구조가 다르다면 아키텍처 관련 결정에도 차이가 난다. 개발자가 다섯명이라면 서로 효율적으로 협력하며 모노리틱(monilithic)시스템을 개발 할 수 있다.&lt;/p&gt;

&lt;p&gt;다른 한편으로 일곱 명씩 구성된 총 다섯팀이 시스템을 개발하고 있다면 시스템을 신뢰할 수 있고 안정된 인터페이스를 갖춘, 잘 설계된 컴포넌트 단위로 분리하지 않으면 개발이 진척되지 않는다. 다른 요소를 고려하지 않는다면 이 시스템의 아키텍처는 다섯 개의 컴포넌트로(즉, 각 팀마다 하나씩) 발전될 가능성이 높다.&lt;/p&gt;

&lt;p&gt;이러한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;팀별 단일 컴포넌트&lt;/code&gt; 아키텍처가 시스템을 배포, 운영, 유지보수 하는데 최적일 가능성은 거의 없다. 그럼에도 여러 팀이 순전히 일정에만 쫒겨서 일한다면, 결국 이 아키텍처로 귀착될 것이다.&lt;/p&gt;

&lt;h2 id=&quot;배포&quot;&gt;배포&lt;/h2&gt;

&lt;p&gt;배포 비용이 높을 수록 시스템의 유용성은 떨어진다. 따라서 소프트웨어 아키텍처는 시스템을 단 한 번에 쉽게 배포할 수 있도록 만드는 데 그 목표를 두어야 한다.&lt;/p&gt;

&lt;p&gt;안타깝지만 초기 개발 단계에서는 배포 전략을 거의 고려하지 않는다.&lt;/p&gt;

&lt;p&gt;예를 들어 개발 초기에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;마이크로서비스 아키텍처&lt;/code&gt;를 사용하자고 결정한다면 컴포넌트 경계가 뚜렿해지고 인터페이스가 대체로 안정화되므로 시스템을 매우 쉽게 개발 할 수 있다고 판단했을지도 모른다.&lt;/p&gt;

&lt;p&gt;하지만 배포할 시기가 되면 위협적일 만큼 늘어난 수많은 마이크로서비스를 발견하게 될지도 모른다.&lt;/p&gt;

&lt;p&gt;만약 아키텍트가 배포 문제를 초기에 고려했다면 이와는 다른 결정을 내렸을 것이다.&lt;/p&gt;

&lt;p&gt;더 적은 서비스를 사용하고, 서비스 컴포넌트와 프로세스 수준의 컴포넌트를 하이브리드 형태로 융합하며, 좀 더 통합 된 도구를 사용하여 상호 연결을 관리했을 것이다.&lt;/p&gt;

&lt;h2 id=&quot;운영&quot;&gt;운영&lt;/h2&gt;

&lt;p&gt;아키텍처가 시스템 운영에 미치는 영향은 개발, 배포, 유지보수에 미치는 영향보다는 덜 극적이다. 운영에서 겪는 대다수의 어려움은 소프트웨어 아키텍처에는 극적인 영향을 주지 않고도 단순히 하드웨어를 더 투입해서 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;하드웨어는 값 싸고 인력은 비싸다는 말이 뜻하는 바는 운영을 방해하는 아키텍처가 개발, 배포, 유지보수를 방해하는 아키텍처보다는 비용이 덜 든다는 뜻이다.&lt;/p&gt;

&lt;p&gt;시스템을 쉽게 운영하게 해주는 아키텍처가 바람직하지 않다는 말이 아니다. 다만 비용 공식 관점에서 운영보다는 개발, 배포, 유지보수 쪽으로 더 기운다는 말이다.&lt;/p&gt;

&lt;p&gt;그렇다라도 시스템을 운영할 때 아키텍처가 맡은 또 다른 역할이 있다. 좋은 소프트웨어 아키텍처는 시스템을 운영하는 데 필요한 요구도 알려준다.&lt;/p&gt;

&lt;p&gt;아키텍처의 이 역할을 달리 표현하면, 시스템 아키텍처가 개발자에게 시스템의 운영 방식을 잘 드러내 준다고 할 수 있다.&lt;/p&gt;

&lt;p&gt;시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급(first-class) 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;유지보수&quot;&gt;유지보수&lt;/h2&gt;

&lt;p&gt;유지보수는 모든 측면에서 봤을 때 소프트웨어 시스템에서 비용이 가장 많이 든다.&lt;/p&gt;

&lt;p&gt;유지보수의 가장 큰 비용은 탐사(spelunking)와 이로 인한 위험부담에 있다.&lt;/p&gt;

&lt;p&gt;탐사란 기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때, 소프트웨어를 파헤쳐서 어디를 고치는 게 최선인지, 그리고 어떤 전략을 쓰는게 최적일지 결정할 때 드는 비용이다.&lt;/p&gt;

&lt;p&gt;주의를 기울여 신중하게 아키텍처를 만들면 이 비용을 크게 줄일 수 있다. 시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 서로 격리한다.&lt;/p&gt;

&lt;p&gt;이를 통해 미래에 추가 될 기능에 대한 길을 밝혀 둘 수 있을 뿐만 아니라 의도치 않은 장애가 발생할 위험을 크게 줄일 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;선택사항-열어두기&quot;&gt;선택사항 열어두기&lt;/h2&gt;

&lt;p&gt;소프트웨어는 두 종류의 가치, 즉 행위적 가치와 구조적 가치를 지닌다. 이 중에서 구조적 가치가 더 중요한데, 소프트웨어를 부드럽게(soft) 만들기 때문이다.&lt;/p&gt;

&lt;p&gt;소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 한 많이, 그리고 가능한 한 오랫동안 열어 두는 것이다. 그렇다면 열어둬야 할 선택사항은 무엇인가?? 바로 중요치 않은 세부사항(detail)이다.&lt;/p&gt;

&lt;p&gt;모든 소프트웨어 시스템은 주요한 두 가지 구성요소로 분해 할 수 있다.&lt;/p&gt;

&lt;p&gt;바로 정책(policy)과 세부사항이다. 정책 요소는 모든 업무 규칙과 업무 절차를 구체화 한다. 정책이란 시스템의 진정한 가치가 살아 있는 곳이다.&lt;/p&gt;

&lt;p&gt;세부사항은 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소지만, 정책이 가진 행위에는 조금도 영향을 미치지 않는다.&lt;/p&gt;

&lt;p&gt;예를 들어 세부사항에는 입출력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등이 있다.&lt;/p&gt;

&lt;p&gt;아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는데 있다. 이를 통해 세부사항을 결정하는 일을 미루거나 연기할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;좋은 아키텍트는 결정되지 않은 사항의 수를 최대화 한다.&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;장치-동립성&quot;&gt;장치 동립성&lt;/h2&gt;

&lt;p&gt;이전 프로그래머의 대표적인 실수 중 하나는 코드를 입출력 장치와 직접 결합해버린 일이었다. 프린터로 인쇄할 일이 있다면, 해당 프린터를 제어하는 입출력 명령어를 직접 사용해서 코드로 작성했다. 이러한 코드는 장치 종속적(device dependent)이 었다.&lt;/p&gt;

&lt;p&gt;1960년 후반에 어르러서야 장치 독립성(device independence)를 생각해 냈다. 오늘날의 운영체제는 입출력 장치를 소프트웨어 함수로 추상화했고, 해당 함수는 천공카드와 같은 단위 레코드를 처리한다.&lt;/p&gt;

&lt;p&gt;동일한 프로그램을 아무런 변경 없이도 카드에서 읽고 쓰거나 테이브에서 읽고 쓸 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;개발 폐쇄 원칙이 탄생한 순간이다.&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;광고-우편&quot;&gt;광고 우편&lt;/h2&gt;

&lt;p&gt;1960년 대 후반에 나는 광고 우편을 인쇄하는 회사에서 일했다. 의뢰인은 고객의 이름과 주소가 포함한느 단위 레코드가 기록 된 자기 테이프를 우리에게 보내주고 우리는 개인화된 광고를 멋지게 프린트하는 프로그램을 작성하였다.&lt;/p&gt;

&lt;p&gt;그러나 안타깝게도 IBM 360과 라인 프린트 하나만 이용해서 인쇄했고 매우 느렸다. 그래서 우리는 자기 테이프를 사용하도록 운영체제에게 지시하여 IBM 360가 10여분 만에 자기 테이프를 가득 채워서 쏟아냈다. 우리는 그 것을 가지고 오프라인 프린트로 수십만 장의 광고 우편을 인쇄하였다.&lt;/p&gt;

&lt;p&gt;장치 동립성이 지닌 가치는 굉징했다. 어떤 장치를 사용할지 전혀 모른채, 그리고 고려하지 않고도 프로그램을 작성할 수 있었다.&lt;/p&gt;

&lt;p&gt;이 경우 정책은 이름과 주소 레코드에 대한 서식이었다. 세부사항은 장치였다. 우리는 어떤 장치를 사용할지에 대한 결정을 연기시켰다.&lt;/p&gt;

&lt;h2 id=&quot;물리적-주소할당&quot;&gt;물리적 주소할당&lt;/h2&gt;

&lt;p&gt;1970년대 초에 나는 회계 시스템을 만들고 있었다. 25MB의 크기의 디스크 드라이브에 여러 Agent, Employer, Member의 레코드를 저장했다.&lt;/p&gt;

&lt;p&gt;그렇게 우리는 소프트웨어가 디스크의 상세 구조를 알도록 만들 었다. 즉 소프트웨어는 디스크가 200개의 실린더와 10개의 헤드로 구성되며, 각 실린더는 헤드별 수십 개의 섹터로 구성된다는 사실을 알게 되었다. 이러한 정보가 모드 하드 코딩이었다.&lt;/p&gt;

&lt;p&gt;그런데 만약 헤더가 더 많거나 실린더가 더 많은, 또는 실린더당 섹터가 더 많은 새로운 디스크 드라이브로 업그레이드해야 한다면 무슨 일이 벌어질까? 하드 코딩된 코드를 전부 수정해야 한다.&lt;/p&gt;

&lt;p&gt;어느날 노련한 프로그래머가 우리 조직에 합류하였고 그는 친절하게 주소 할당 체계를 변경하여 상대 주소를 사용하라고 충고해 주었다.&lt;/p&gt;

&lt;p&gt;다행이도 우리는 그의 조언을 받아들여, 시스템에서 고수준의 정책이 디스크의 물리적 구조로부터 독립되도록 수정했다. 그 덕분에 우리는 디스크 드라이브 구조에 대한 결정사항을 애플리케이션으로부터 분리할 수 있게 되었다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;좋은 아키텍트는 세부사항을 정책으로 부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다.&lt;/p&gt;

&lt;p&gt;이를 통해 정책은 세부사항에 관한 어떤 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다.&lt;/p&gt;

&lt;p&gt;좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.&lt;/p&gt;
</description>
        <pubDate>Sun, 08 May 2022 18:00:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch15/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch15/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>5부 아키텍처</category>
        
      </item>
    
      <item>
        <title>14장. 컴포넌트 결합</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch14/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;컴포넌트-결합&quot;&gt;컴포넌트 결합&lt;/h1&gt;

&lt;p&gt;지금 부터 다룰 세 가지 원칙은 컴포넌트 사이의 관계를 설명한다. 개발 가능성과 논리적 설계 사이의 균형을 다룬다.&lt;/p&gt;

&lt;p&gt;컴포넌트 구조와 관련된 아키텍처를 침번하는 힘은 기술적이며, 정치적이고, 가변적이다.&lt;/p&gt;

&lt;h2 id=&quot;adp-의존성-비순환-원칙&quot;&gt;ADP: 의존성 비순환 원칙&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안 된다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;하루 종일 일해서 무언가를 작동하게 만들고 퇴근 했는데, 이튿날 전혀 돌아가지 않는 경험을 해본적 있는가? 누군가 당신보다 더 늦게까지 일하며 의존하고 있던 무언가를 수정했기 때문이다.&lt;/p&gt;

&lt;p&gt;나는 이러한 현상을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;숙취 증후군(the morning after syndrome)&lt;/code&gt;이라고 부른다.&lt;/p&gt;

&lt;p&gt;프로젝트의 규모가 커지면 커질 수록 이러한 숙취는 지독한 악몽이 될 수 있다. 누군가가 마지막에 수정한 코드 때문에 망가진 부분이 동작하도록 만들기 위해 코드를 수정하고 또 수정하는 작업만이 계속 된다.&lt;/p&gt;

&lt;p&gt;해결책으로는 첫 번째 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;주 단위 빌드(weekly build)&lt;/code&gt;이며 두 번째는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;의존성 비순황 원칙(Acyclic Dependencies Principle, ADP)&lt;/code&gt;이다.&lt;/p&gt;

&lt;h3 id=&quot;주-단위-빌드weekly-build&quot;&gt;주 단위 빌드(Weekly Build)&lt;/h3&gt;

&lt;p&gt;주 단위 빌드는 중간 규모의 프로젝트에서는 흔하게 사용된다. 모든 개발자가 일주일의 첫 4일 동안은 서로를 신경쓰지 않고 개발하며 금요일이 되면 변경된 코드를 모두 통합하여 시스템을 빌드한다.&lt;/p&gt;

&lt;p&gt;이 접근법은 5일 중 4일 동안 개발자를 고립된 세계에서 살 수 있게 해주지만 금요일에 통합과 관련된 막대한 업보를 치러야 한다.&lt;/p&gt;

&lt;p&gt;하지만 안타깝게도 프로젝트가 커지면 통합이 금요일 하루 만에 끝나지 않는다.&lt;/p&gt;

&lt;p&gt;개발보다 통합에 드는 시간이 늘어나면서 팀의 효율서도 서서히 나빠진다.&lt;/p&gt;

&lt;h3 id=&quot;순환-의존성-제거하기&quot;&gt;순환 의존성 제거하기&lt;/h3&gt;

&lt;p&gt;이 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다. 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.&lt;/p&gt;

&lt;p&gt;개발자가 해당 컴포넌트를 동작하도록 만든 후, 해당 컴포넌트를 릴리스하여 다른 개발자가 사용할 수 있도록 만든다.&lt;/p&gt;

&lt;p&gt;컴포넌트가 새로 릴리스되어 사용할 수 있게 되면, 다른 팀에서는 새 릴리스를 당장 적용할지를 결졍해야 한다. 새 릴리스를 적용할 준비가 되었다는 판단이 들면 새 릴리스를 사용하기 시작하면 된다.&lt;/p&gt;

&lt;p&gt;이 같은 작업 절차는 단순하며 합리적이지만 이 절차가 성공적으로 동작하려면 컴포넌트 사잉의 의존성 구조를 반드시 관리해야 한다. 의존성 구조에 순화이 있어서는 안된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch14/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;전형적인 컴포넌트 다이어그램&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 그림의 중요한 점은 컴포넌트 간의 의존성 구조다. 이 구조가 방향 그래프(directed graph)엠에 주의하자. 컴포넌트는 정점(vertex)에 해당하고, 의존성 관계는 방향이 있는 간선(directed edge)에 해당한다.&lt;/p&gt;

&lt;p&gt;또한 위 그림의 의존성 구조는 비순환 방향 그래프(Directed Acyclic Graph, DAG)이다.&lt;/p&gt;

&lt;p&gt;Presenters 컴포넌트를 만드는 개바랒가 이 컴포넌트를 테스트하고자 한다면, 단순히 현재 사용 중인 버전의 Interactors와 Entities를 이용해서 Presenters 자체 버전을 빌드하면 그만이다. 이 빌드 과정에서 시스템의 나머지 컴포넌트는 전혀 관련이 없다.&lt;/p&gt;

&lt;p&gt;시스템 전체를 릴리스 해야 할때가 온다면 릴릴스 절차는 상향식으로 진행하면 된다. Entities 컴포넌트를 컴파일하고, 테스트하고, 리리리스 한다. 그러고 나서 database와 Interactors에 대해서도 동일한 과정을 거친다.&lt;/p&gt;

&lt;p&gt;이 처럼 구성요소 간 의존성을 파일하고 있으면 시스템을 빌드하는 방법을 알 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;순환이-컴포넌트-의존성-그래프에-미치는-영향&quot;&gt;순환이 컴포넌트 의존성 그래프에 미치는 영향&lt;/h3&gt;

&lt;p&gt;새로운 요구사항이 발생해서 Entities에 포함된 클래스 하나가 Authorizer에 포함된 클래스 하나를 사용하도록 변경할 수밖에 없다고 가정해 보다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch14/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;순환 의존성&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위와 같이 순환 의존성(dependency cycle)이 발생하며 이 순환은 즉각적인 문제를 일으킨다.&lt;/p&gt;

&lt;p&gt;예를 들어 Database 컴포넌트를 만드는 개발자가 릴리스하려면 Entities 컴포넌트와 반드시 호환되너야 한다느 사실을 알고 있다. 하지만 Entitites 컴포넌트에는 순환이 있으므로, Database 컴포넌트는 또한 Authorizer와도 호환되어야 한다.&lt;/p&gt;

&lt;p&gt;이 말은 결국 개발자들은 모두, 이들 컴포넌트 중 어느 것을 개발하더라도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;숙취 증후군&lt;/code&gt;에 떠는 경험을 하게 될 것이다.&lt;/p&gt;

&lt;p&gt;의존성 그래프에 순환이 생기면 컴포넌트를 어떤 순서로 빌드해야하 하는지 파악하기 힘들어진다.&lt;/p&gt;

&lt;h3 id=&quot;순환-끊기&quot;&gt;순환 끊기&lt;/h3&gt;

&lt;p&gt;컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG로 원상복구 하는 일은 언제라도 가능하다. 아래의 두 가지  메커니즘을 살펴 보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;의존성 역전 원칙(DIP)를 적용한다. User가 필요한 메서드를 제공하는 인터페이스를 생성한다. 그리고 이 인터페이스는 Entities에 위치시키고, Authorizer에서는 이 인터페이스를 상속받는다. 이렇게 하면 Entities와 Authorizer 사이의 의존성을 역전시킬 수 있고, 이를 통해 순환을 끊을 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch14/4.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Entities와 Authorizer 사이의 의존성을 역전 시킨다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;Entities와 Authorizer가 모두 의존하는 새로운 컴포넌트를 만든다. 그리고 두 컴포넌트가 모두 의존하는 클래스드릉르 새로운 컴포넌트로 이동 시킨다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch14/5.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Entities와 Authorizer 모두가 의존하는 새로운 컴포넌트&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;흐트러짐jitters&quot;&gt;흐트러짐(Jitters)&lt;/h3&gt;

&lt;p&gt;두 번째 해결책에서 시사하는 바는 요구사항이 변경되면 컴포넌트 구조도 변경 될 수 있다는 사실이다. 실제로 애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장한다.&lt;/p&gt;

&lt;p&gt;따라서 의존성 구조에 순환이 발생하는지를 항상 관찰해야 한다. 순환이 발생하면 어떤 식으로든 끊어야 한다.&lt;/p&gt;

&lt;p&gt;이 말은 때로 새로운 컴포넌트를 생성하거나 의존성 구조가 더 커질 수 있음을 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;하향식top-down-설계&quot;&gt;하향식(top-down) 설계&lt;/h2&gt;

&lt;p&gt;지금까지 논의로 우리는 피할 수 없는 결론에 다다른다. 즉, 컴포넌트 구조는 하향식으로 설계 될 수 없다. 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경 될 때 까지 함께 진화한다.&lt;/p&gt;

&lt;p&gt;사실 컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 일과는 거의 관련이 없다. 그렇게 때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다. 빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도 또한 필요없기 때문이다.&lt;/p&gt;

&lt;p&gt;하지만 프로젝트를 개발하기 위해서 의존성 관리에 대한 요구가 점처 늘어나게 되며 변경되는 범위가 시스템의 가능한 한 작은 일부로 한정되기를 원한다.&lt;/p&gt;

&lt;p&gt;결국 단일 책임 원칙(SRP)과 공통 폐쇄 원칙(CCP)에 관심을 갖기 시작하고, 이를 적용해 함께 변경되는 클래스는 같은 위치에 배치되도록 만든다.&lt;/p&gt;

&lt;p&gt;의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일이다. 컴포넌트 의존성 그래프는 자주 변겨오디는 컴포넌트로부터 안정적으며 가치가 높은 컴포넌트를 보호하려는 아키텍트가 만들고 가다듬게 된다.&lt;/p&gt;

&lt;p&gt;아직 아무런 클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계하려고 시도한다면 상단히 큰 실패를 맛볼 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;sdp--안정된-의존성-원칙&quot;&gt;SDP : 안정된 의존성 원칙&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안정성의 방향으로 (더 안정된 쪽에) 의존하라&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;설계는 결코 정적일 수 없다. 설계를 유지하다 보면 변경이 불가피하다. 공통 폐쇄 원칙을 준수함으로써, 컴포넌트가 다른 유형의 변경에는 영향을 받지 않으면서도 특정 유형의 변경에만 민감하게 만들 수 있다.&lt;/p&gt;

&lt;p&gt;우리는 변동성을 지니도록 설계한 컴포넌트는 언젠가 변경되리라고 예상한다.&lt;/p&gt;

&lt;p&gt;즉, 당신이 모듈을 만들때는 변경하기 쉽도록 설계했지만, 이 모듈에 누군가가 의존성을 매달아 버리면 당신의 모듈도 변경하기 어려워진다.&lt;/p&gt;

&lt;p&gt;안정된 의존성 원칙(Stable Dependencies Principle, SDP)을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;안정성&quot;&gt;안정성&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안정성(stability)&lt;/code&gt;는 무슨 뜻인가? 안정성은 변화가 발생하는 빈도와는 직접적인 관련이 없다.&lt;/p&gt;

&lt;p&gt;소프트웨어 컴포넌트를 변경하기 어렵게 만드는 데는 많은 요인이 존재하며, 그 예로는 컴포넌트의 크기, 복잡도, 간결함 등을 들 수 있다.&lt;/p&gt;

&lt;p&gt;소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다.&lt;/p&gt;

&lt;p&gt;아래의 그램에서 X 컴포넌트는 안정된 컴포넌트다. 세 컴포넌트가 X에 의존하며, 따라서 X 컴포넌트는 변경하지 말아야 할 이유가 세 가지나 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch14/6.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;X는 안정된 컴포넌트다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;아래의 그림의 Y는 상당히 불안정한 컴포넌트다. 어떤 컴포넌트도 Y에 의존하지 않으므로 Y는 책임성이 없다고 말할 수 있다. 또한 Y는 세 개의 컴포넌트에 의존하므로 변경이 발생할 수 있는 외부 요인이 세 가지다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch14/7.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Y는 상당히 불안정한 컴포넌트다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;안정성-지표&quot;&gt;안정성 지표&lt;/h3&gt;

&lt;p&gt;컴포넌트의 안정성을 측정하는 방법은 의존성의 개수를 세어 보는 방법이 있다. 이 숫자를 통해 컴포넌트가 위치상(positional) 어느 정도의 안정성을 가지는지 계산할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Fan-in : 안으로 들어오는 의존성
    &lt;ul&gt;
      &lt;li&gt;의존하는 외부 컴포넌트의 클래스 갯수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Fan-out : 바깥으로 나가는 의존성
    &lt;ul&gt;
      &lt;li&gt;외부 클래스에 의존하는 컴포넌틑 내부의 클래스 개수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;I(불안정성) : I = Fan-out % (Fan-in + Fan-out).
    &lt;ul&gt;
      &lt;li&gt;I = 0이면 최고로 안정된 컴포넌트&lt;/li&gt;
      &lt;li&gt;I = 1이면 최고로 불안정한 컴포넌트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SDP에서 컴포넌트의 I 지표는 그 컴포넌트가 의존하는 다른 컴포넌트들의 I보다 커야 한다고 말한다.&lt;/p&gt;

&lt;p&gt;즉, 의존성 방향이 갈수록 I 지표 값이 감소해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;모든-컴포넌트가-안정적이여야-하는-것은-아니다&quot;&gt;모든 컴포넌트가 안정적이여야 하는 것은 아니다.&lt;/h3&gt;

&lt;p&gt;모든 컴포넌트가 최고로 안정적인 시스템은 변경이 불가능하다. 사실 우리가 컴포넌트 구조를 설계할 때 기대하는 것은 불안정한 컴포넌트도 있고 안정된 컴포넌트도 존재하는 상태다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch14/8.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;세 컴포넌트로 구성된 시스템이 이상적인 구조&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다이어그램에서 불안정한 컴포넌트를 관례적으로 위쪽에 두는데, 이 관례를 따르면 상당히 유용하다. 위로 향하는 화살표가 있으면 SDP를 위배하는 상태가 되기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch14/9.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;SDP 위배&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Flexible은 변경하기 쉽도록 설계한 컴포넌트다. 하지만 Stable 컴포넌트에서 작업하던 개발자가 Flexible에 의존성을 걸게 되면 이로 인해 SDP를 위배하는데, 결국 Flexible은 변경하기 어렵게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch14/10.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;수정 된 그림&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 그림과 같이 불안정한 컴포넌트를 위에 배치하면 한눈에 알아보기 쉽다.&lt;/p&gt;

&lt;p&gt;위와 같은 문제를 해결하려면 Stable의 Flexible에 대한 의존성은 어떤 식으로든 끊어야한다. 이 의존성은 무슨 이유로 존재하는가? Stable 내부의 클래스 U가 Flexible 내부의 클래스 C를 사용한다고 가정해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch14/11.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Stable 내부의 클래스 U가 Flexible 내부의 클래스 C를 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;DIP를 도입하면 이 문제를 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch14/12.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;C는 US 인터페이스를 구현한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;추상-컴포넌트&quot;&gt;추상 컴포넌트&lt;/h3&gt;

&lt;p&gt;오로지 인터페이스만을 포함하는 컴포넌트(위 예제의 UServer)를 생성하는 방식이 이상하게 보일 수도 있다.&lt;/p&gt;

&lt;p&gt;하지만 C#이나 Java 같은 정적 타입 언어를 사용할 때 이 방식은 상당히 흔할 뿐만 아니라, 꼭 필요한 전략이다.&lt;/p&gt;

&lt;p&gt;이러한 추상 컴포넌트는 상당히 안정적이며, 따라서 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.&lt;/p&gt;

&lt;h2 id=&quot;sap-안정된-추상화-원칙&quot;&gt;SAP: 안정된 추상화 원칙&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;컴포넌트는 안정된 정도만큼만 추상화되어야 한다.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;고수준-정책을-어디에-위치시켜야-하는가&quot;&gt;고수준 정책을 어디에 위치시켜야 하는가?&lt;/h3&gt;

&lt;p&gt;시스템에서 자주 변경시켜서는 안되는 소프트웨어도 있다. 고수준 아키텍처나 정책결정과 관련된 소프트웨어가 그 예다.&lt;/p&gt;

&lt;p&gt;이처럼 업무 로직이나 아키텍처와 관련된 결정에는 변동성이 없기를 기대한다.&lt;/p&gt;

&lt;p&gt;하지만 고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스 코드는 수정하기 어려워진다. 이로 인해 시스템 전체 아키텍처가 유연성을 잃는다.&lt;/p&gt;

&lt;p&gt;해답은 개방 폐쇄 원칙(OCP)에서 착을 수 있다. OCP는 클래스를 수정하지 않고도 확장이 충분히 가능할 정도로 클래스를 유연하게 만들 수 있다.&lt;/p&gt;

&lt;p&gt;어떤 클래스가 이 원칙을 준수하는가? 바로 추상(abstract) 클래스다.&lt;/p&gt;

&lt;h3 id=&quot;안정된-추상화-원칙&quot;&gt;안정된 추상화 원칙&lt;/h3&gt;

&lt;p&gt;안정된 추상화 원칙(Stable Abstractions Principle, SAP)는 안정성과 추상화 정도 사이의 관계를 정의한다.&lt;/p&gt;

&lt;p&gt;이 원칙은 한편으로는 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안 된다고 말한다. 다른 한편으로는 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 말하는데, 컴포넌트가 불안정하므로 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문이다.&lt;/p&gt;

&lt;p&gt;따라서 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;SAP와 SDP를 결합하면 컴포넌트에 대한 DIP나 마찬가지가 된다. 실제로 SDP에서는 의존성이 반드시 안정성의 방향으로 향해야 한다고 말하며, SAP에서는 안정성이 결국 추상화를 의미한다고 말하기 때문이다. 따라서 의존성은 추상화의 방향으로 향하게 된다.&lt;/p&gt;

&lt;p&gt;하지만 DIP는 클래스에 대한 원칙이며, 클래스의 경우 중간은 존재하지 않는다.&lt;/p&gt;

&lt;p&gt;즉, 클래스는 추상적이거나 아니거나 둘 중 하나다. SDP와 SAP의 조합은 컴포넌트에 대한 원칙이며, 컴포넌트는 어떤 부분은 추상적이면서 다른 부분은 안정적일 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;추상화-정도-측정하기&quot;&gt;추상화 정도 측정하기&lt;/h3&gt;

&lt;p&gt;A 지표는 컴포넌트의 추상화 정도를 측정한 값이다. 이 값은 컴포넌트의 클래스 총 수 대비 인터페이스와 추상 클래스의 개수를 단순히 계산한 값이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Nc: 컴포넌트의 클래스 개수&lt;/li&gt;
  &lt;li&gt;Na: 컴포넌트의 추상 클래스와 인터페이스의 개수&lt;/li&gt;
  &lt;li&gt;A: 추상화 정도. A = Na % Nc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A 지표는 0과 1 사이의 값을 갖는다. A가 0이면 컴포넌트에는 추상 클래스가 하나도 없다는 뜻이다. A가 1이면 컴포넌트는 오로지 추상 클래스만을 포함한다는 뜻이다.&lt;/p&gt;

&lt;h3 id=&quot;주계열&quot;&gt;주계열&lt;/h3&gt;

&lt;p&gt;아래의 그래프는 안정성(I)과 추상화 정도(A)사이의 관계를 정의한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch14/13.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A/I 그래프&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;최고로 안정적이며 추상화된 컴포넌트는 좌측 상단이 (0,1)에 위치하고 최고로 불안정하고 구체화된 컴포넌트는 우측하단(1,0)에 위치한다.&lt;/p&gt;

&lt;p&gt;모든 컴포넌트가 좌측 상단, 우측 하단에 위치 할 수 없음으로 합리적인 지점을 정의하는 점의 궤적이 있으리라고 가정해 볼 수 있다.&lt;/p&gt;

&lt;p&gt;이 궤적은 컴포넌트가 절대로 위치해서는 안 되는 영역, 다시 말해 배제할 구역(Zone of Exclusion)을 찾는 방식으로 추론할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch14/14.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;배제 구역(Zone of Exclusion)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;고통의-구역&quot;&gt;고통의 구역&lt;/h3&gt;

&lt;p&gt;(0,0) 주변의 컴포넌트는 매우 안정적이며 구체적이다. 이는 바람직한 상태가 아닌데, 뻣뻣한 상태이기 때문이다.&lt;/p&gt;

&lt;p&gt;추상적이지 않아 확장할 수 없고, 안정적이므로 변경하기 상당히 어렵다.&lt;/p&gt;

&lt;p&gt;사실 일부 소프트웨어 엔티티는 고통의 구역에 위치하곤 한다. 데이터베이스 스키마가 한 예이다. 스키마는 변동성이 높기로 악명이 높다.&lt;/p&gt;

&lt;p&gt;또 다른 예는 구체적인 유틸리티 라이브러리를 들 수 있다. 하지만 이러한 라이브러리는 I 지표가 1일지라도, 실제로 변동성이 거의 없다. 예를 들어 String 컴포넌트이다.&lt;/p&gt;

&lt;p&gt;변동성이 거의 없는 컴포넌트는 (0,0) 구역에 위치했더라도 해롭지 않다. 변동 될 가능성이 거의 없기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;쓸모없는-구역&quot;&gt;쓸모없는 구역&lt;/h3&gt;

&lt;p&gt;(1,1) 주변의 컴포넌트는 추상적이지만, 누구도 그 컴포넌트에 의존하지 않는다. 이는 쓸모가 없는 컴포넌트다.&lt;/p&gt;

&lt;p&gt;이 영역에 존재하는 엔티티는 폐기물과도 같다. 엔티티는 누구도 구현하지 않은 채 남겨친 추상 클래스인 경우가 많다.&lt;/p&gt;

&lt;h3 id=&quot;배제-구역-벗어나기&quot;&gt;배제 구역 벗어나기&lt;/h3&gt;

&lt;p&gt;변동성이 큰 컴포넌트 대부분은 두 배제 구역으로부터 가능한 한 멀리 떨어뜨려야 한다.&lt;/p&gt;

&lt;p&gt;이 선분이 주계열(Main Sequence)라고 부르며, 주계열에 위치한 컴포넌트는 자신의 안정성에 비해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;너무 추상적&lt;/code&gt;이지도 않고, 추상화 정도에 비해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;너무 불안정&lt;/code&gt;하지도 않다.&lt;/p&gt;

&lt;p&gt;컴포넌트가 위칳라 수 있는 가장 바람직한 지점은 주계열의 두 종점이다.&lt;/p&gt;

&lt;h3 id=&quot;주계열과의-거리&quot;&gt;주계열과의 거리&lt;/h3&gt;

&lt;p&gt;컴포넌트가 주계열 바로 위에, 또는 가까이 있는 것이 바람직하다면, 이 같은 이상적인 상태로부터 컴포넌트가 얼마나 멀리 떨어져 있는지 측정하는 지표를 말들어 볼 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;D: 거리. D =&lt;/td&gt;
          &lt;td&gt;A + I - 1&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;ul&gt;
      &lt;li&gt;유효범위는 [0,1]&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;D가 0이면 컴포넌트가 주계열 바로 위에 위치하고, 1이면 주계열로부터 가장 멀리 위치한다.&lt;/p&gt;

&lt;p&gt;지표를 사용하면 컴포넌트를 재검토 후 재구성 할 수 있고 통계적으로 분석하는 일 또한 가능해진다.&lt;/p&gt;

&lt;p&gt;모든 컴포넌트에 대해 D 지표의 평균과 분산을 구한다. 분산은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;관리 한계(Control limit)&lt;/code&gt;를 결정하기 위한 목적으로 사용할 수 있고, 분산을 통해 다른 컴포넌트에 비해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;극히 예외적인&lt;/code&gt; 컴포넌트를 식별 할 수 있다.&lt;/p&gt;

&lt;p&gt;아래의 그림에서 보듯이 일부 컴포넌트의 표준편차가 1(Z=1)인 영역을 벗어나 있다.&lt;/p&gt;

&lt;p&gt;이처럼 이상한 컴포넌트는 좀 더 면밀히 검토해 볼 가치가 있다. 이들 컴포넌트는 자신에게 의존하는 컴포넌트가 거의 없는데도 너무 추상적이거나, 자신에게 의존하는 컴포넌트가 많은데도 너무 구체적일 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch14/15.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;컴포넌트 산점도&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;의존성 관리 지표는 설계의 의존성과 추상화 정도가 내가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;훌륭한&lt;/code&gt; 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다.&lt;/p&gt;

&lt;p&gt;하지만 지표는 그저 임의로 결정된 표준을 기초로 한 측정값에 지나지 않는다. 이러한 지표는 아무리 해도 불완전하다. 하지만 이들 지표로부터 무언가 유용한 것을 찾을 수 있기를 바란다.&lt;/p&gt;

</description>
        <pubDate>Sun, 08 May 2022 16:00:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch14/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch14/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>4부 컴포넌트 원칙</category>
        
      </item>
    
      <item>
        <title>13장. 컴포넌트 응집도</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch13/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;컴포넌트-응집도&quot;&gt;컴포넌트 응집도&lt;/h1&gt;

&lt;p&gt;어떤 클래스를 어느 컴포넌트에 포함시켜야 할까? 이 장에서는 컴포넌트 응집도와 관련된 세 가지 원칙을 논의한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;REF : 재사용/릴리스 등가원칙(Reuse/Release Equivalence Principle)&lt;/li&gt;
  &lt;li&gt;CCP : 공통 폐쇄 원칙(Commom Closure Principle)&lt;/li&gt;
  &lt;li&gt;CRP : 공통 재사용 원칙(Common Reuse Principle)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rep-재사용릴리스-등가-원칙&quot;&gt;REP: 재사용/릴리스 등가 원칙&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;재사용 단위는 릴리스 단위와 같다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;우리는 이제 소프트웨어 재사용의 시대에 살고 있다. 객체 지향 모델의 오랜 약속 중 하나가 실현되었다.&lt;/p&gt;

&lt;p&gt;돌이켜 보면 재사용/릴리스 등가 원칙(REP)는 너무 당연하다. 릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀 없다.&lt;/p&gt;

&lt;p&gt;이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻한다. 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다.&lt;/p&gt;

&lt;p&gt;하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스 할 수 있어야 하며 버전 번호가 같아야 하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어 한다.&lt;/p&gt;

&lt;p&gt;하지만 이것으로 클래스와 모듈을 단일 컴포넌트로 묶는 방법을 제대로 설명 할 수 없다.&lt;/p&gt;

&lt;p&gt;이 원칙의 약점은 다음에 다룰 두 원칙이 지닌 강점을 통해 충분히 보완할 수 있다.&lt;/p&gt;

&lt;p&gt;실제로 CCP와 CRP는 REP를 엄격하게, 하지만 제약을 가하는 측면에서 정의한다.&lt;/p&gt;

&lt;h2 id=&quot;cpp--공통-폐쇄-원칙&quot;&gt;CPP : 공통 폐쇄 원칙&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이 원칙은 단일 책임 원칙(SRP)을 컴포넌트 관점에서 다시 쓴 것이다.&lt;/p&gt;

&lt;p&gt;대다수의 애플리케이션에서 유지보수성(maintainability)은 재사용성보다 훨씬 중요하다. 애플리케이션에서 코드가 반드시 변겨오디어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기보다는, 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.&lt;/p&gt;

&lt;p&gt;CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권한다. 이를 통해 소프트웨어를 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화 할 수 있다.&lt;/p&gt;

&lt;p&gt;이 원칙은 개발 폐쇄 원칙(OCP)와 밀접하게 관련되어 있는데, CCP에서 말하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;폐쇄(closure)&lt;/code&gt;는 OCP에서 말하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;폐쇄(closure)&lt;/code&gt;와 그 뜻이 같다.&lt;/p&gt;

&lt;p&gt;100% 폐쇄란 불가능하므로 전략적으로 폐쇄해야 한다. 우리는 발생할 가능성이 있거나 과거에 발생했던 대대수의 공통적인 변경에 대해서 클래스가 닫혀 있도록 설계한다.&lt;/p&gt;

&lt;p&gt;CCP는 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음으로써 OCP에서 얻은 교훈을 확대 적용 한다.&lt;/p&gt;

&lt;h3 id=&quot;srp와의-유사성&quot;&gt;SRP와의 유사성&lt;/h3&gt;

&lt;p&gt;CCP는 컴포넌트 수준의 SRP다. SRP에서는 서로 다른 이유로 변경되는 메서드를 서로 다른 클래스로 분리하라고 말한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동일한 시점에 동일한 이유로 변경되는 것을들 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;crp-공통-재사용-원칙&quot;&gt;CRP: 공통 재사용 원칙&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;컴포넌트 사용자들을 필요하지 않은 것에 의존하게 강요하지 말라.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;공통 재사용 원칙(CRP)도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움되는 원칙이다. CRP에서는 같은 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말한다.&lt;/p&gt;

&lt;p&gt;예를 들어 컨테이너(container) 클래스와 해당 클래스의 이터레이터(iterator) 클래스를 들 수 있다. 이들 클래스는 서로 강하게 결합되어 있기 때문에 함께 재사용된다. 따라서 이들 클래스는 반드시 동일한 컴포넌트에 위치해야 한다.&lt;/p&gt;

&lt;p&gt;컴포넌트가 다른 컴포넌트를 사용하면 의존성이 생긴다. 사용되는 컴포넌트가 변경되면 사용하는 컴포넌트 또한 변경 될 가능성이 높다.&lt;/p&gt;

&lt;p&gt;따라서 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다. 바꿔 말하면, 한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없다. 즉, 일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음을 확실히 인지해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;isp와의-관계&quot;&gt;ISP와의 관계&lt;/h3&gt;

&lt;p&gt;CRP는 인터페이스 분리 원칙(ISP)의 포괄적인 버전이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;필요하지 않은 것에 의존하지 말라&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;컴포넌트-응집도에-대한-균형-다이어그램&quot;&gt;컴포넌트 응집도에 대한 균형 다이어그램&lt;/h2&gt;

&lt;p&gt;아마도 응집도에 관한 세 원칙이 서로 상충된다는 사실을 눈치챘을 거라고 본다.&lt;/p&gt;

&lt;p&gt;REP와 CCP는 포함(include)원칙이다. 즉, 두 원칙은 컴포넌트를 더욱 크게 만든다.&lt;/p&gt;

&lt;p&gt;CRP는 배제(exclusive)원칙이며, 컴포넌트를 더욱 작게 만든다.&lt;/p&gt;

&lt;p&gt;아래의 그림은 균형(tension) 다이어그램으로, 응집도에 관한 세 원칙이 서로 어떻게 상호작용하는지 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch13/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;REP와 CRP에만 중점을 두면, 사소한 변경에 너무 많은 컴포넌트에 영향을 미친다.&lt;/li&gt;
  &lt;li&gt;CCP와 REP에만 과도하게 집중하면 불필요한 릴리스가 너무 빈번해진다.&lt;/li&gt;
  &lt;li&gt;CRP와 CCP에만 집중하게 되면 재사용성이 떨어지게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적으로 프로젝트는 삼각형의 오른쪽에서 시작하는 편이며, 이때는 오직 재사용성만 희생하면 된다.&lt;/p&gt;

&lt;p&gt;프로젝트가 성숙하고, 그 프로젝트로부터 파생된 또 다른 프로젝트가 시작되면, 프로젝트는 삼각형에서 점차 왼쪽으로 이동해 간다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;과거의 결합도에 대한 우리의 인식 수준이 REP, CCP, CRP가 의미하는 것보다는 훨씬 단순했다.&lt;/p&gt;

&lt;p&gt;응집도를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모듈은 단 하나의 기능만 수행해야 한다&lt;/code&gt;는 속성 정도로 단순하게 이해한적도 있다.&lt;/p&gt;

&lt;p&gt;어느 클래스들을 묶어서 컴포넌트로 만들지를 결정할 때, 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야 한다. 심지어 이 균형점은 거의 항상 유동적이다.&lt;/p&gt;
</description>
        <pubDate>Sun, 08 May 2022 14:10:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch13/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch13/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>4부 컴포넌트 원칙</category>
        
      </item>
    
      <item>
        <title>12장. 컴포넌트 원칙</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch12/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;컴포넌트-원칙&quot;&gt;컴포넌트 원칙&lt;/h1&gt;

&lt;p&gt;컴포넌트는 배포 단위다. 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.&lt;/p&gt;

&lt;p&gt;자바에서는 jar 파일이 컴포넌트이고, 닷넷에서는 DLL이다.&lt;/p&gt;

&lt;p&gt;컴포넌트가 가장 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다.&lt;/p&gt;

&lt;h2 id=&quot;컴포넌트의-간략한-역사&quot;&gt;컴포넌트의 간략한 역사&lt;/h2&gt;

&lt;p&gt;소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했다. 프로그램의 시작부에는 프로그램이 로드 될 주소를 선언하는 오리진(origin) 구문이 나와야 했다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;              *200
              TLS
START,        CLA
              TAD BUFR
              JMS GETSTR
              CLA
              TAD BUFR
              JMS PUTSTR
              JMP START
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;프로그램 시작부에 있는 *200은 메모리 주소 200&lt;sub&gt;8&lt;sub&gt;에 로드할 코드를 생성하라고 컴파일러에 알려준다.&lt;/sub&gt;&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;이 시대에는 장치는 느리고 메모리는 너무 비싸 메모리가 소스 코드 전체를 메모리에 상주시킬 수가 없었다.&lt;/p&gt;

&lt;p&gt;결국 컴파일러는 느린 장치를 이용해서 소스 코드를 여러차례 읽어야만 했다.&lt;/p&gt;

&lt;p&gt;컴파일 시간을 단축시키기 위해 프로그래머는 함수 라이브러리와 소스 코드를 애플리케이션 코드로부터 분리했다.&lt;/p&gt;

&lt;p&gt;하지만 애플리케이션 마져 점점 커져서 두 개의 주소 세그먼트로 분리하여 함수 라이브러리 공간을 사이에 두고 오가며 동작하게 배치해야 했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch12/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;애플리케이션을 두 개의 주소 세그먼트로 분리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그러나 이러한 배치에서 함수 라이브러리 마저 커지게 된다면 할당된 메모리 주소를 넘어서게 되고 결국 추가 공간을 할당해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;재배치성&quot;&gt;재배치성&lt;/h2&gt;

&lt;p&gt;위의 문제를 해결하기 위해서는 재배치가 가능한 바이너리(relocatable binary)였다.&lt;/p&gt;

&lt;p&gt;재배치 로더가 여러 개의 바이너리의 위치 정보를 전달받아 새롭게 재배치 하였다. 이를 통해 프로그래머는 피룡한 함수만 로드 할 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;또한 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정하였다. 만약 프로그램이 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 외부 참조(external reference)로 생성했다. 반면 라이브러리 함수를 정의하는 프로그램이라면 외부 정의(external definition)을 생성했다.&lt;/p&gt;

&lt;p&gt;이렇게 링킹 로더(linking loader)가 탄생했다.&lt;/p&gt;

&lt;h2 id=&quot;링커&quot;&gt;링커&lt;/h2&gt;

&lt;p&gt;링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할 할 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;하지만 링킹 로더는 너무 느려서 로드와 링크가 두 단계로 분리 되었다.&lt;/p&gt;

&lt;p&gt;프로그래머가 느린 부분, 링크 과정을 맡았는데, 링커(linker)라는 벼롣의 애플리케이션으로 이 작업을 처리하도록 만들었다.&lt;/p&gt;

&lt;p&gt;하지만 1980년대가 되어 C나, 다른 고수준 언어를 사용하게 되며 또 다시 전체 모듈을 컴파일 하는 시간이 오래 걸리게 되었고 링커에서는 더 많은 시간이 소요 되었다.&lt;/p&gt;

&lt;p&gt;로드 시간은 여진히 빨랐지만 컴파일-링크 시간이 병목 구간이었다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;컴파일하고 링크하는 데 사용 가능한 시간을 모두 소모할 때까지 프로그램은 커진다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;하지만 무어의 법칙이 생겨나면서 메모리는 저렴해지고 RAM에 모두 캐싱 할 수 있을 정도로 커졌다.&lt;/p&gt;

&lt;p&gt;이렇게 액티브 X와 공유 라이버러리 시대가 열렸고, .jar 파일도 등장하기 시작했다. 컴퓨터와 장치가 빨라져서 또다시 로드와 링크를 동시에 할 수 있게 되었다. 다수의 .jar 파일 또는 다수의 공유라이브러리를 순식간에 서로 링크한 후, 링크가 끝난 프로그램을 실행할 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;이렇게 컴포넌트 플러그인 아키텍처(component plugin architecture)가 탄생했다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;
&lt;p&gt;런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다.&lt;/p&gt;

</description>
        <pubDate>Sun, 08 May 2022 14:00:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch12/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch12/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>4부 컴포넌트 원칙</category>
        
      </item>
    
      <item>
        <title>11장. DIP, 의존성 역전 원칙</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch11/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;dip-의존성-역전-원칙&quot;&gt;DIP: 의존성 역전 원칙&lt;/h1&gt;

&lt;p&gt;의존성 역전 원칙에서 말하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'유연성이 극대화된 시스템'&lt;/code&gt;이란 소스 코드 의존성이 추상(abstraction)에 의존하며 구체(concretion)에는 의존하지 않는 시스템이다.&lt;/p&gt;

&lt;p&gt;자바 같은 정적 타입 언어에서는 이 말은 use, import, include 구분이 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 뜻이다. 구체적인 대상에는 절대로 의존해서는 안된다.&lt;/p&gt;

&lt;p&gt;루비나 파이썬 같은 동적 타입에도 소스 코드 의존 관계에서 구체 모듈은 참조해서는 안된다.&lt;/p&gt;

&lt;p&gt;하지만 String 같은 클래스는 구체 클래스이며, 이를 의존하지 않기는 어렵다.&lt;/p&gt;

&lt;p&gt;반면 String 클래스는 변경되는 일은 거의 없으며, 있어도 엄격하게 통제된다.&lt;/p&gt;

&lt;p&gt;이러한 이유로 DIP를 논할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰(volatile) 구체적인 요소이다.&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;안정된-추상화&quot;&gt;안정된 추상화&lt;/h2&gt;

&lt;p&gt;추상 인터페이스에 변경이 생기면 이를 구체화환 구현체들도 따라서 수정해야 한다. 반대로 구체적인 구현체에 변경이 생기더라도 그 구현체가 구현하는 인터페이스는 대다수의 경우 변경될 필요가 없다. 따라서 인터페이스는 구현체보다 변동성이 낮다.&lt;/p&gt;

&lt;p&gt;즉, 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 안키텍처라는 뜻이다.&lt;/p&gt;

&lt;h3 id=&quot;변동성이-큰-구체-클래스를-참조하지-말라&quot;&gt;변동성이 큰 구체 클래스를 참조하지 말라.&lt;/h3&gt;

&lt;p&gt;대신 추상 인터페이스를 참조하라. 이 규칙은 객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리(Abstract Factory)를 사용하도록 강제한다.&lt;/p&gt;

&lt;h3 id=&quot;변동성이-큰-구체-클래스로부터-파생하지-말라&quot;&gt;변동성이 큰 구체 클래스로부터 파생하지 말라.&lt;/h3&gt;

&lt;p&gt;정적 타입 언어에서는 상속은 소스 코드에 존재하는 모든 관계 중에서 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다. 따라서 상속은 아주 신중하게 사용해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;구체-함수를-오버라이드-하지-말라&quot;&gt;구체 함수를 오버라이드 하지 말라.&lt;/h3&gt;

&lt;p&gt;대체로 구체 함수는 소스 코드 의존성을 필요로 한다. 따라서 구체 함수를 오버라이드 하면 이러한 의존성을 제거할 수 없게 되며, 실제로는 그 의존성을 상속하게 된다.&lt;/p&gt;

&lt;p&gt;이러한 의존성을 제거하려면, 차라리 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;구체적인-변동성이-크다면-절대로-그-이름을-언급하지-말라&quot;&gt;구체적인 변동성이 크다면 절대로 그 이름을 언급하지 말라.&lt;/h3&gt;

&lt;p&gt;사실 이 실천법은 DIP 원칙을 다른 방식으로 풀어쓴 것이다.&lt;/p&gt;

&lt;h2 id=&quot;팩토리&quot;&gt;팩토리&lt;/h2&gt;

&lt;p&gt;객체 지향 언어에서 바람직하지 못한 의존성을 처리할 때 추상 패토리를 사용하곤 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-08-PPPCleanArchitecture_ch11/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;의존성을 관리하기 위해 추상 팩토리(Abstract Factory) 패턴을 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 그림에서 곡선은 아키텍처 경계를 뜻한다. 이 곡선은 구체적인 것들로부터 추상적인 것들을 분리한다. 소스 코드 의존성은 해당 곡선과 교차할 때 모두 한 방향, 즉 추상적인 쪽으로 향한다.&lt;/p&gt;

&lt;p&gt;곡선은 시스템을 두 가지 컴포넌트로 분리한다. 하나는 추상 컴포넌트이며, 다른 하나는 구체 컴포넌트다. 추상 컴포넌트는 애플리케이션의 모든 고수준 업무 규칙을 포함한다.&lt;/p&gt;

&lt;p&gt;제어흐름은 소스코드 의존성과는 정반대 방향으로 곡선을 가로지른다는 점에 주목한다. 다시 말해 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다.&lt;/p&gt;

&lt;p&gt;이러한 이유로 이 원칙을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;의존성 역전(Dependency Inversion)&lt;/code&gt;이라고 부른다.&lt;/p&gt;

&lt;h2 id=&quot;구체-컴포넌트&quot;&gt;구체 컴포넌트&lt;/h2&gt;

&lt;p&gt;이전 그림에서 구체 컴포넌트에는 구체적인 의존성(Service Factory Impl - ConcreteImpl)이 하나 있고, 따라서 DIP에 위반 된다.&lt;/p&gt;

&lt;p&gt;이는 일반적이며 DIP 위배를 모두 없앨 수는 없다.&lt;/p&gt;

&lt;p&gt;대다수의 시스템은 이러한 구체 컴포넌트를 최소한 하나는 포함할 것이다. 흔히 이 컴포넌트를 메인(Main)이라고 부르는데, main 함수를 포함하기 때문이다.&lt;/p&gt;

&lt;p&gt;main 함수는 ServiceFactoryImpl의 인스턴스를 생성한 후, 이 인스턴스를 ServiceFactory 타입으로 전역 변수에 저장할 것이다. 그런 다음 Application은 이 전역 변수를 이용해서 ServiceFactoryImpl의 인스턴스에 접근할 것이다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;그림에서 곡선은 이후의 장에서는 아키텍처 경계가 될 것이다. 그리고 의존성은 이 곡선을 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향한다. 추후 이 규칙은 의존성 규칙(Dependency Rule)이라 부를 것이다.&lt;/p&gt;

</description>
        <pubDate>Sun, 08 May 2022 13:30:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch11/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch11/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>3부 설계 원칙</category>
        
      </item>
    
      <item>
        <title>10장. ISP, 인터페이스 분리 원칙</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch10/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;isp-인터페이스-분리-원칙&quot;&gt;ISP: 인터페이스 분리 원칙&lt;/h1&gt;

&lt;p&gt;인터페이스 분리 원칙은 아래의 다이어그램에서 그 이름이 유래했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch10/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;인터페이스 분리 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;User1은 오직 op1을 User2는 op2만을, User3는 op3만을 사용한다고 가정한다.&lt;/p&gt;

&lt;p&gt;이 경우 User1은 op2와 op3를 전혀 사용하지 않음에도 User1의 소스코드는 이 두 메서드에 의존하게 된다.&lt;/p&gt;

&lt;p&gt;이러한 의존성으로 인해 op2가 수정되면 User1도 다시 컴파일 후 새로 배포해야 한다.&lt;/p&gt;

&lt;p&gt;그래서 아래와 같인 인터페이스를 분리해여 관리 하여야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch10/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;분리된 오퍼레이션&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;isp와-언어&quot;&gt;ISP와 언어&lt;/h2&gt;

&lt;p&gt;앞에서 본 사례는 언터 타입에 의존한다. 정적 타입 언어는 사용자가 import, use 또는 include와 같은 타입 선언문을 사용하도록 강제 한다.&lt;/p&gt;

&lt;p&gt;이처럼 소스 코드에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;포함된included&lt;/code&gt; 선언문으로 인해 소스 코드 의존성이 발생하고, 이로 인해 재컴파일 또는 재배포가 강제되는 상황이 무조건 초래한다.&lt;/p&gt;

&lt;p&gt;루비나 파이썬 같은 동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때보다 유연하며 결합도가 낮은 시스템을 만들 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 사실로 인해 ISP를 아키텍처가 아니라, 언어와 관련된 문제라고 결론 내릴 여지가 있다.&lt;/p&gt;

&lt;h2 id=&quot;isp와-아키텍처&quot;&gt;ISP와 아키텍처&lt;/h2&gt;

&lt;p&gt;일반적으로 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다. 소스코드 의존성의 경우 이는 분명한 사실인데, 불필요한 재컴파일과 재배포를 강제하기 때문이다. 하지만 더 고수준인 아키텍처 수준에서도 마찬가지 상황이 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch10/4.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;문제가 있는 아키텍처&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 그림은 S 시스템 구축에 참여하는 아키텍트가 F라는 프레임워크를 시스템에 도입하기를 원한다. 그리고 F 프레임워크 개발자는 특정한 D 데이터베이스를 반드시 사용하도록 만들었다고 가정한다.&lt;/p&gt;

&lt;p&gt;따라서 S는 F에 의존하며, F는 다시 D에 의존하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;불필요한 짐을 실은 무언가에 의존하면 예상치 못한 문제에 빠진다.&lt;/p&gt;

</description>
        <pubDate>Thu, 05 May 2022 23:50:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch10/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch10/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>3부 설계 원칙</category>
        
      </item>
    
      <item>
        <title>9장. LSP, 리스코프 치환 원칙</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch9/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;lsp--리스코프-치환-원칙&quot;&gt;LSP : 리스코프 치환 원칙&lt;/h1&gt;

&lt;p&gt;1988년 바바라 리스코프(Barbara Liskov)는 하위 타입(subtype)을 아래와 같이 정의 했다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;S 타입의 객체 o1에 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;상송을-사용하도록-가이드하기&quot;&gt;상송을 사용하도록 가이드하기&lt;/h2&gt;

&lt;p&gt;아래의 그림과 같이 License라는 클래스가 있다고 했을 때, License는 PersonalLicense와 BusinessLicense라는 두 가지 ‘하위 타입’이 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch9/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;License와 파생 클래스는 LSP를 준수한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 설계는 LSP를 준수하는데 Bulling 애플리케이션의 행위가 License 하위 타입 중 무엇을 사용하는지에 전혀 의존하지 않기 때문이다. 이들 하위 타입은 모두 License 타입을 치환할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;정사각형직사각형-문제&quot;&gt;정사각형/직사각형 문제&lt;/h2&gt;

&lt;p&gt;LSP를 위반하는 전형적인 문제로는 유명한 정사각형/직사각형 문제가 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch9/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;악명 높은 정사각형/직사각형 문제&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 예제에서 Square는 Rectangle의 하위 타입으로는 적합하지 않다.&lt;/p&gt;

&lt;p&gt;Rectangle의 높이와 너비는 서로 독립적으로 변경될 수 있는 반면, Square의 높이와 너비는 반드시 함께 변경되기 때문이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Rectangle r = ...
r.setW(5);
r.setH(2);
assert(r.area() == 10)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;… 코드에서 Square를 생성한다면 assert문은 실패하게 된다.&lt;/p&gt;

&lt;p&gt;if문 등을 이용해서 Square인지 검사하는 메커니즘을 User에 추가해야 하기 때문에 User는 행위가 사용하는 타입에 의존하게 되므로, 결국 타입을 서로 치환할 수 없게 된다.&lt;/p&gt;

&lt;h2 id=&quot;lsp-아키텍처&quot;&gt;LSP 아키텍처&lt;/h2&gt;

&lt;p&gt;잘 정의 된 인터페이스와 그 인터페이스의 구현체끼리의 상호 치환 가능성에 기대는 사용자들이 존재하기 때문에 많은 상황에 LSP를 적용 할 수 있다.&lt;/p&gt;

&lt;p&gt;아키텍처 관점에서 LSP를 이해하는 최선의 방법은 이 원칙을 어겼을 때 시스템 아키텍처에서 무슨 일이 일어나는지 관찰하는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;lsp-위배-사례&quot;&gt;LSP 위배 사례&lt;/h2&gt;

&lt;p&gt;LSP를 위배하여 개발을 하게 된다면 고객의 요구사항에 대해 예외 사항을 처리하는 로직을 추가해야 한다.&lt;/p&gt;

&lt;p&gt;만약 택시 파견 서비스를 통합하는 애플리케이션을 만들고 있다고 해본다.&lt;/p&gt;

&lt;p&gt;퍼플캡이라는 회사에서 아래와 같이 URL을 통해 파견 정보를 호출한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;purplecab.com/driver/Bob
	/pickupAddress/24 Maple St.
    /pickupTime/153
    /destination/ORD
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또 애크미라는 택시업체가 있고 그 업체의 프로그래머들은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;destination&lt;/code&gt;을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dest&lt;/code&gt;로 축약하여 사용하고 있다.&lt;/p&gt;

&lt;p&gt;그런데 이 둘 회사가 합쳐진다고 한다면 모든 파견 명령어에 아래와 같이 if 문장을 추가해야 한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;if (driver.getDispatchUri().startsWith(&quot;acme.com&quot;).....
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실력 있는 아키텍트라면 당연히 시스템을 이런 식으로 구성하는 것을 용납하지 않는다.&lt;/p&gt;

&lt;p&gt;아키텍트는 이 같은 버그로 부터 시스템을 격리해야 한다.&lt;/p&gt;

&lt;p&gt;이때 파견 URI를 키로 사용하는 설정용 데이터베이스를 이용하는 파견 명령 생성 모듈을 만들어야 할 수도 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;URI&lt;/th&gt;
      &lt;th&gt;Dispatch Format&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Acme.com&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;/pickupAddress/%s/pickupTime/%s/dest/%s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.*&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;/pickupAddress/%s/pickupTime/%s/destination/%s&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;또한 아키텍트는 REST 서비스들의 인터페이스가 서로 치환 가능하지 않다는 사실을 처리하는 중요하고 복잡한 매커니즘을 추가해야 한다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다.&lt;/p&gt;

&lt;p&gt;치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.&lt;/p&gt;
</description>
        <pubDate>Thu, 05 May 2022 23:30:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch9/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch9/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>3부 설계 원칙</category>
        
      </item>
    
      <item>
        <title>8장. OCP, 개방-폐쇄 원칙</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch8/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;ocp-개방-폐쇄-원칙&quot;&gt;OCP: 개방-폐쇄 원칙&lt;/h1&gt;

&lt;p&gt;개방-폐쇄 원칙(OCP)이라는 용어는 1988년에 버트란트 마이어(Bertrand Meyer)가 만들었는데, 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;소프트웨어 개체(artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;다시 말해 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다.&lt;/p&gt;

&lt;p&gt;소프트웨어 아키텍처를 공부하는 가장 근본적인 이유이기도 하다. 만약 요구사항을 살짝 확장하는 데 소프트웨어를 엄청나게 수정해야 한다면 그 소프트웨어 시스템을 설계한 아키텍트는 엄청난 실패에 맞닥뜨린 것이다.&lt;/p&gt;

&lt;p&gt;대다수 개발자들은 OCP가 클래스와 모듈을 설계할 때 도움되는 원칙이라고 알고 있지만 아키텍처 컴포넌트 수준에서 OCP를 고려할 때 훨씬 중요한 의미를 가진다.&lt;/p&gt;

&lt;h2 id=&quot;사고-실행&quot;&gt;사고 실행&lt;/h2&gt;

&lt;p&gt;제무제표를 웹 페이지로 보여주는 시스템이 있다고 가정한다.&lt;/p&gt;

&lt;p&gt;웹 페이지에 표시되는 데이터는 스크롤할 수 있으며, 음수는 빨간색으로 출력한다.&lt;/p&gt;

&lt;p&gt;하지만 이해관계자가 동일한 정보를 보고서 형태로 변환해서 흑백 프린터로 출력해 달라고 요청했다고 해보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 번호가 있어야 한다.&lt;/li&gt;
  &lt;li&gt;페이지 마다 적절한 머리글과 바닥글이 있어야 한다.&lt;/li&gt;
  &lt;li&gt;표의 각 열에는 레이블이 있어야 한다.&lt;/li&gt;
  &lt;li&gt;음수는 괄호로 감싸야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;소프트웨어 악키텍처가 훌륭하다면 변경되는 코드의 양이 가능한 한 최소화 될 것이다. 이상적인 변경량은 0이다.&lt;/p&gt;

&lt;p&gt;서로 다른 목적으로 변경되는 요소를 적절하게 분리하고(단일 책임 원칙SRP), 이들 요소 사이의 의존성을 체계화함으로써(의존성 역전 원칙DIP) 변경량을 최소화 할 수 잇다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch8/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;SRP 적용하기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;여기서 가장 중요한 영감은 보고서 생성이 두 개의 책임으로 분리된다는 사실이다.&lt;/p&gt;

&lt;p&gt;이 처럼 웹과 프린터로 분리가 되어 있다면 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스 코드 의존성도 확실히 조직화해야 한다.&lt;/p&gt;

&lt;p&gt;또한, 새로운 조직화한 구조에서는 행위가 확장 될 때 변경이 발생하지 않음을 보장해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch8/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;처리 과정을 클래스 단위로 분할하고, 클래스는 컴포넌트 단위로 분리한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 그림에서 좌측 상단의 컴포넌트는 Controller이고 우측 상단은 Interractor 컴포넌트를, 우측 하단에서는 Database 컴포넌트를 볼 수 있다. 좌측 하단에는 Presenter와 View를 담당하는 네 가지 컴포넌트가 위치한다.&lt;/p&gt;

&lt;p&gt;여기서 주목할 점은 모든 의존성이 소스 코드 의존성을 나타낸다는 사실이다. FinancialDataMapper는 구현 관계를 통해 FinancialDataGateway를 알고 있지만, FinancialDataGateway는 FinancialDataMapper에 대해 아무것도 알지 못한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch8/4.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;컴포넌트 관계는 단방향으로만 이루어진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;모든 컴포넌트 관계는 단방향으로 이루어진다. 이들 화살표는 변경으로 부터 보호하려는 컴포넌트를 향햐도록 그려진다.&lt;/p&gt;

&lt;p&gt;A 컴포넌트에서 발생한 변경으로 부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Presenter에서 발생한 변경으로부터 Controller를 보호하고자 한다.&lt;/li&gt;
  &lt;li&gt;View에서 발생한 변경으로부터 Presenter를 보호하고자 한다.&lt;/li&gt;
  &lt;li&gt;Interactor는 다른 모든 것에서 발생한 변경으로부터 보호하고자 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Interator는 OCP를 가장 잘 준수할 수 있는 곳에 위치한다. Database, Controller, Presenter, View에서 발생한 어떤 변경도 Interator에 영향을 주지 않는다.&lt;/p&gt;

&lt;p&gt;Interactor는 업무 규칙을 포함하기 때문에 애플리케이션에서 가장 높은 수준의 정책을 포함해야 한다.&lt;/p&gt;

&lt;p&gt;아키텍트는 기능이 어떻게(how), 왜(why), 언제(when) 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다.&lt;/p&gt;

&lt;p&gt;컴포넌트 계층구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;방향성-제어&quot;&gt;방향성 제어&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch8/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 다이어그램은 컴포넌트 간 의존성이 제대로 된 방향으로 향하고 있음을 보여준다.&lt;/p&gt;

&lt;p&gt;예를 들어 FinancialDataGateway 인터페이스는 FinancialReportGenerator와 FinancialDataMapper 사이에 위치하는데, 이는 의존성을 역전시키기 위해서다.&lt;/p&gt;

&lt;h2 id=&quot;정보은닉&quot;&gt;정보은닉&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch8/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;FinancialReportRequester 인터페이스는 방향성 제어와는 다른 목적을 가진다. 이 인터페이스는 FinancialReportController가 Interactor 내부에 대해 너무 많이 알지 못하도록 막기 위해서 존재한다.&lt;/p&gt;

&lt;p&gt;만약 이 인터페이스가 없다면 Controller는 FinancialEntities에 대해 추이 종속성(transitive dependency)를 가지게 된다.&lt;/p&gt;

&lt;p&gt;추이 종속성을 가지게 되면, 소프트웨어 엔티티는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다.&lt;/code&gt;는 소프트웨어 원칙을 위반하게 된다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;OCP는 시스템의 아키텍처가 떠받치는 원동력 중 하나다. OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.&lt;/p&gt;

&lt;p&gt;이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고 수준 컴포넌트를 보호 할 수 있는 형태의 의존성 계층 구조가 만들어지도록 해야 한다.&lt;/p&gt;
</description>
        <pubDate>Thu, 05 May 2022 21:00:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch8/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch8/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>3부 설계 원칙</category>
        
      </item>
    
      <item>
        <title>7장. SRP, 단일 책임 원칙</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch7/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;srp-단일-책임-원칙&quot;&gt;SRP: 단일 책임 원칙&lt;/h1&gt;

&lt;p&gt;SOLID 원칙 중에서 그 의미가 가장 잘 전달되지 못한 원칙은 바로 단일 책임 원칙(SRP)이다.&lt;/p&gt;

&lt;p&gt;프로그래머 입장에서는 모든 모듈이 단 하나의 일만 해야 한다는 의미로 받아들이기 쉽다.&lt;/p&gt;

&lt;p&gt;헷갈리면 안된다. 함수가 단 하나의 일을 해야한다는 원칙을 가지고 있고 SRP의 의미는 아래와 같다&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;변경을 요청하는 한 명 이상의 사람들을 액터(Actor)라고 부른다면 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모듈&lt;/code&gt;이란 가장 단순한 정의는 바로 소스 파일이다. 모듈은 단순히 함수와 데이터 구조로 구성된 응집된 집합이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;응집된(cohesive)&lt;/code&gt;이라는 단어가 SRP를 암시한다. 단일 액터를 책임지는 코드를 함께 묶어 주는 힘이 바로 응집성이다.&lt;/p&gt;

&lt;h2 id=&quot;징후-1-우발적-중복&quot;&gt;징후 1: 우발적 중복&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch7/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Employee 클래스&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 클래스는 세 가지 메서드 calculatePay() reportHours(), save()를 가진다.&lt;/p&gt;

&lt;p&gt;이 클래스는 SRP를 위반하는데, 이들 세 가지 메서드가 서로 매우 다른 세명의 액터를 책임지기 때문이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;calculatePay() 메서드는 회계팀에서 기능을 정의하며, CFO 보고를 위해 사용한다.&lt;/li&gt;
  &lt;li&gt;reportHours() 메서드는 인사팀에서 기능을 정의하고 사용하며, COO 보고를 위해 사용한다.&lt;/li&gt;
  &lt;li&gt;save() 메서드는 데이터베이스 관리자(DBA)가 기능을 정의하고, CTO 보고를 위해 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;세 액터가 서로 결합되어 버려 CFO 팀에서 결정한 조치가 COO팀이 의존하는 무언가에 영향을 줄 수 있다.&lt;/p&gt;

&lt;p&gt;예를 들어 calculatePay() 메서드와 reportHours() 메서드가 초과 근무를 제외한 업무 시간을 계산하는 알고리즘을 공유한다고 해보자.&lt;/p&gt;

&lt;p&gt;그리고 개발자는 코드 중복을 피하기 위해 이 알고리즘을 regularHours()라는 메서드에 넣었다고 해보자&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch7/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;공유된 알고리즘&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이제 CFO팀에서 초과 근무를 제외한 업무 시간을 계산하는 방식을 약간 수정하기로 결정했다고 하자. 반면 인사를 담당하는 COO팀에서는 초과 근무를 제외한 업무 시간을 CFO 팀과는 다른 목적으로 사용하기 때문에, 이 같은 변경을 원하지 않는다고 해보자.&lt;/p&gt;

&lt;p&gt;이 변경을 적용하는 업무를 할당받은 개발자는 calculatePay() 메서드가 펴느이 메서드인 regularHours()를 호출한다는 사실을 발견한다. 하지만 안타깝게도 이 함수가 reportHours() 메서드에서도 호출된다는 사실을 눈치채지 못한다.&lt;/p&gt;

&lt;h2 id=&quot;징후-2--병합&quot;&gt;징후 2 : 병합&lt;/h2&gt;

&lt;p&gt;소스 파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생하고 이들 메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성이 확실히 더 높다.&lt;/p&gt;

&lt;p&gt;두 명의 서로 다른 개발자가, 그리고 아마도 서로 다른 팀에 속했을 두 개발자가 Employee 클래스를 체크아웃 받은 후 변경사항을 적용하기 시작하면 안타깝게도 이들 변경 사항이 서로 충돌한다. 결과적으로 병합이 발생한다.&lt;/p&gt;

&lt;p&gt;병합에는 위험이 따른다고 굳이 말하지 않아도 될 것이다. 어떤 도구도 병합이 발생하는 모든 경우를 해결할 수는 없다.&lt;/p&gt;

&lt;p&gt;이 문제를 벗어나는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;해결책&quot;&gt;해결책&lt;/h2&gt;

&lt;p&gt;이 문제의 해결책은 다양한데, 그 모두가 메서드를 각기 다른 클래스로 이동시키는 방식이다. 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식이다.&lt;/p&gt;

&lt;p&gt;즉, 아무런 메서드가 없는 간단한 데이터 구조인 EmployeeData 클래스를 만들어, 세 개의 클래스가 공유하도록 한다.&lt;/p&gt;

&lt;p&gt;각 클래스는 자신의 메서드에 반드시 필요한 소스 코드만 포함한다. 세 클래스는 서로의 존재를 몰라야 한다. 따라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우연한 중복&lt;/code&gt;을 피할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch7/4.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;세 클래스는 서로의 존재를 알지 못한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;반면 이 해결책은 개발자가 세 가지 클래스를 인스턴스화하고 추적해야 한다는 게 단점이다. 이러한 난관에서 빠져나올 때 흔히 쓰는 기법으로 퍼사드(Facade) 패턴이 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch7/5.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;퍼사드(Facade) 패턴&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;EmployeeFacade에 코드는 거의 없다. 이 클래스는 세 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.&lt;/p&gt;

&lt;p&gt;가장 중요한 엄무 규칙을 데이터와 가깝게 배치하는 방식을 선호한다면 아래와 같이 기존의 Employee 클래스를 그대로 유지하되, Employee 클래스를 덜 중요한 나머지 메서드들에 대한 퍼사드로 사용 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-05-PPPCleanArchitecture_ch7/6.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;가장 중요한 메서드는 기존의 Employee 클래스에 그대로 유지하되, Employee 클래스를 덜 중요한 나머지 메서드들에 대한 퍼사드로 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 처럼 여러 메서드가 하나의 가족을 이루고, 메서드의 가족을 포함하는 각 클래스는 하나의 유효범위가 된다.&lt;/p&gt;

&lt;p&gt;해당 유효범위 바깥에서는 이 가족에게 감춰진 식구(private 멤버)가 있는지를 전혀 알 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;p&gt;단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 하지만 이보다 상위 두 수준에서도 다른 형태로 다시 등장한다.&lt;/p&gt;

&lt;p&gt;컴포넌트 수준에서는 공통 패쇄 원칙(Common Closure Principle)이 된다.&lt;/p&gt;

&lt;p&gt;아키텍처 수준에서는 아키텍처 경계(Architectural Boundary)의 생성을 책임지는 변경의 축(Axis of Change)이 된다.&lt;/p&gt;

</description>
        <pubDate>Thu, 05 May 2022 20:30:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch7/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch7/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>3부 설계 원칙</category>
        
      </item>
    
      <item>
        <title>6장. 함수형 프로그래밍</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-02-PPPCleanArchitecture_ch6/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;함수형-프로그래밍&quot;&gt;함수형 프로그래밍&lt;/h1&gt;

&lt;p&gt;이 패러다임에서 핵심이 되는 기반은 람다(lambda) 계산법으로 알론조 처치(alonzo Church)가 1930년대에 발명했다.&lt;/p&gt;

&lt;h2 id=&quot;정수를-제곱하기&quot;&gt;정수를 제곱하기&lt;/h2&gt;

&lt;p&gt;함수형 프로그래밍이 무엇인지 설명하기 위해 아래의 예제를 보자&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Squint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;리스프에서 파생한 클로저(Clojure)는 함수형 언어로 아래와 같이 구현 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;take&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;___&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;출력한다&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;take&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;___&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;처음부터&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;까지&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;](*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;___&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;제곱을&lt;/span&gt;
             &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;___&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;정수의&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자바는 가변 변수(mutable variable)를 사용하는데, 가변 변수는 프로그램 실행 중에 상태가 변할 수 있다.&lt;/p&gt;

&lt;p&gt;반복문을 제어하는 변수인 i가 가변 변수다.&lt;/p&gt;

&lt;p&gt;하지만 클로저에서는 x와 같은 변수가 한 번 초기화 되면 절대로 변하지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;불변성와-아키텍처&quot;&gt;불변성와 아키텍처&lt;/h2&gt;

&lt;p&gt;왜 아키텍트는 변수의 가변성을 염려해야 하는가?? 단순한 이유이지만 경합(race)조건, 교착 상태(deadlock) 조건, 동시 업데이트(concurrent update) 문제가 모두 가변 변수로 인해 발생하기 때문이다.&lt;/p&gt;

&lt;p&gt;락(lock)이 가변적이지 않다면 교착상태도 일어나지 않는다.&lt;/p&gt;

&lt;p&gt;아키텍트라면 동시성(concurrency)문제에 지대한 관심을 가져야만 한다.&lt;/p&gt;

&lt;h2 id=&quot;가변성의-분리&quot;&gt;가변성의 분리&lt;/h2&gt;

&lt;p&gt;불변성과 관련하여 가장 주요한 타협 중 하나는 애플리케이션, 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-02-PPPCleanArchitecture_ch6/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;상태 변경과 트랜잭션 메모리(transactional memory)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로, 흔히 트랜잭션 메모리(transactional memory)와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호한다.&lt;/p&gt;

&lt;p&gt;트랜잭션 메모리는 데이터베이스가 디스크의 레코드를 다루는 방식과 동일한 방식으로 메모리의 변수를 처리한다. 즉, 트랜잭션을 사용하거나 또는 재시도 기법을 통해 이들 변수를 보호한다.&lt;/p&gt;

&lt;p&gt;하지만 안타깝게도 여러 변수가 상호 의존하는 상황에서는 동시 업데이트와 교착상태 문제로 부터 보호해 주지 못한다.&lt;/p&gt;

&lt;p&gt;애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 한다.&lt;/p&gt;

&lt;p&gt;현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.&lt;/p&gt;

&lt;h2 id=&quot;이벤트-소싱&quot;&gt;이벤트 소싱&lt;/h2&gt;

&lt;p&gt;간단한 예로, 고객의 계좌 잔고를 관리하는 은행 애플리케이션에서 입근 트랜잭션과 출금 트랜잭셩이 실행되면 잔고를 변경해야 한다.&lt;/p&gt;

&lt;p&gt;이제 계좌 잔고를 변경하는 대신 트랜잭션 자체를 저장한다고 상상해 보다.&lt;/p&gt;

&lt;p&gt;터무니 없는 접근법이다. 시간이 지날수록 트랜잭션 수는 끝없이 증가하고, 컴퓨팅 자원은 걷잡을 수 없이 커진다.&lt;/p&gt;

&lt;p&gt;하지만 이 전략이 영원히 동작할 필요는 없다. 애플리케이션의 수명주기 동안만 문제 없이 동작할 정도의 저장 공간과 처리 능력만 있으면 충분할 것이다.&lt;/p&gt;

&lt;p&gt;이것이 이벤트 소싱(event sourcing)의 기본 발상이다.&lt;/p&gt;

&lt;p&gt;이벤스 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.&lt;/p&gt;

&lt;p&gt;결과적으로 애플리케이션은 CRUD가 아니라 CR만 수행한다. 저장공간과 처리능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고, 따라서 완전한 함수형으로 만들수 있다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.&lt;/li&gt;
  &lt;li&gt;객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.&lt;/li&gt;
  &lt;li&gt;함수형 프로그래밍은 변수 항당에 부과되는 규율이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;도구는 달라졌고 하드웨어도 변했지만, 소프트웨어의 핵심은 여전히 그대로다.&lt;/p&gt;

&lt;p&gt;순차(sequence), 분기(selection), 반복(iteration), 참조(indirection)으로 구성된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그 이상도 이하도 아니다.&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 02 May 2022 23:30:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch6/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch6/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>2부 벽돌부터시작하기:프로그래밍 패러다임</category>
        
      </item>
    
      <item>
        <title>5장. 객체 지향 프로그래밍</title>
        <description>&lt;h1 id=&quot;소개&quot;&gt;소개&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-01-PPPCleanArchitecture_ch5/1.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.&lt;/p&gt;

&lt;h1 id=&quot;객체-지향-프로그래밍&quot;&gt;객체 지향 프로그래밍&lt;/h1&gt;

&lt;p&gt;좋은 아키텍처를 만드는 일은 객체지향(OO) 설계 원칙을 이해하고 응용하는 데서 출발한다. 그럼 OO란 무엇인가?&lt;/p&gt;

&lt;p&gt;“데이터와 함수의 조합”의 답은 o.f()가 왼지 f(o)와 다르다는 의미를 내포하고 있어 별로다.&lt;/p&gt;

&lt;p&gt;“시렞 세계를 모델링하는 새로운 방법”의 답은 얼버무리는 수준이다.&lt;/p&gt;

&lt;p&gt;OO의 본질을 설명하기 위해 캡슐화(encapsulation), 상속(inheritance), 다형성(polymorphism)이 세 가지 개념을 적절하게 조합한 것이거나, 또는 OO 언어는 최소한 세 가지 요소를 반드시 지원해야 한다고 말하는 부류들이 있다.&lt;/p&gt;

&lt;h2 id=&quot;캡슐화&quot;&gt;캡슐화?&lt;/h2&gt;

&lt;p&gt;데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다.&lt;/p&gt;

&lt;p&gt;구분선 바깥에서 데이터는 은니고디고, 일부 함수만이 외부에 노출된다.&lt;/p&gt;

&lt;p&gt;사실 C 언어에서도 완벽한 캡슐화가 가능하다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;point.h&lt;/p&gt;
  &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;makePoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;distance&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;point.c
```c
#include “point.h”
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;&lt;/math.h&gt;&lt;/stdlib.h&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;struct Point {
    double x,y;
}&lt;/p&gt;

&lt;p&gt;struct Point* makepoint(double x, double y) {
    struct Point* p = malloc(sizeof(struct Point));
    p-&amp;gt;x = x;
    p-&amp;gt;y = y;
    return p;
}&lt;/p&gt;

&lt;p&gt;double distance(struct Point* p1, struct Point* p2){
    double dx = p1 -&amp;gt; x - p2 -&amp;gt; x;
    double dy = p1 -&amp;gt; y - p2 -&amp;gt; y;
    return sqrt(dx&lt;em&gt;dx+dy&lt;/em&gt;dy);
}&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
point.h를 사용하는 측에서는 `struct Point`의 멤버에 접근할 방법이 전혀 없다.

이것이 바로 완벽한 캡슐화이며, 보다시피 OO가 아닌 언어에서도 충분히 가능하다.

Java와 C#은 헤더와 구현체를 분리하는 방식을 모두 버렸고, 이로 인해 캡슐화는 더웃 심하게 훼손되었다. 이들 언어에서는 클래스 선언과 정의를 구분하는게 아예 불가능하다.

OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 하지만 실제로는 C 언어에서 누렸던 완벽한 캡슐화를 약화시켜 온 것이 틀림없다.

## 상속?

상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불괗다.

&amp;gt; namedPoint.h
```c
struct NamedPoint;

struct NamedPoint* makeNamedPoint(double x, double y, char* name);
void setName(struct NamedPoint* np, char* name);
char* getName(struct NamedPoint* np);
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;namedPoint.c
```c
#include “namedPoint.h”
#include &lt;stdlib.h&gt;&lt;/stdlib.h&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;struct NamedPoint {
    double x,y;
    char *name;
};&lt;/p&gt;

&lt;p&gt;struct NamedPoint* makeNamedPoint(double x, double y, char* name) {
    struct NamedPoint* p = malloc(sizeof(struct NamedPoint));
    p-&amp;gt;x = x;
    p-&amp;gt;y = y;
    p-&amp;gt;name = name;
    return p;
}&lt;/p&gt;

&lt;p&gt;void setName(struct NamedPoint* np, char* name) {
    np-&amp;gt;name = name;
}&lt;/p&gt;

&lt;p&gt;char* getName(struct NamedPoint* np) {
    return np -&amp;gt; name;
}&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
&amp;gt; main.c

```c
#include &quot;point.h&quot;
#include &quot;namedPoint.h&quot;
#include &amp;lt;stdio.h&amp;gt;


int main(int ac, char** av) {
    struct NamedPoint* origin = makeNamedPoint(0.0, 0.0, &quot;origin&quot;);
    struct NamedPoint* upperRight = makeNamePoint(1.0, 1.0, &quot;upperRight&quot;);

    printf(&quot;distance=%f\n&quot;, distance(
        (struct Point*) origin,
        (struct Point*) upperRight
    ));
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;main을 보면 NamedPoint 데이터 구조가 마치 Point 데이터 구조로 부터 파생된 구조인 것처럼 동작한다는 사실을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;NamedPoint는 Point의 가면을 쓴 것처럼 동작 할 수 있는데, 이는 NamedPoint가 순전히 Poiont를 포함하는 상위 집합으로, Point에 대응하는 멤버 변수의 순서가 그대로 유지되기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;다형성&quot;&gt;다형성?&lt;/h2&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;putchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;getchar() 함수는 STDIN에서 문자를 읽는다. 그러면 STDIN은 어떤 장치인가?&lt;/p&gt;

&lt;p&gt;putchar()함수는 STDOUT으로 문자를 쓴다. 그런데 STDOUT은 또 어떤 장치인가?&lt;/p&gt;

&lt;p&gt;이러한 함수는 다형적(polymorphic)이다. 즉, 행위가 STDIN과 STDOUT의 타입에 의존한다.&lt;/p&gt;

&lt;p&gt;FILE 데이터 구조는 열기(open), 닫기(close), 읽기(read), 쓰기(write), 탐색(seek)의 표준함수들을 포함한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;FILE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)();&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;콘솔용 입출력 드라이버에서는 이들 함수를 아래와 같이 정의하며, FILE 데이터 구조를 함수에 대한 주소와 함께 로드한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&quot;file.h&quot;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*...*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*...*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*...*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*...*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*...*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;FILE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;console&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 STDIN을 FILE*로 선언하면, STDIN은 콘솔 데이터 구조를 가리키므로, getchar()는 아래와 같은 방식으로 구현할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;FILE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STDIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;STDIN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수를 가리키는 포인터를 응용한 것이 다형성이라는 점을 말하고 있다.&lt;/p&gt;

&lt;p&gt;1940년대 후반 폰 노이만(Von Neumann) 아키텍처가 처음 구현된 이후 프로그래머는 다형적 행위를 수행하기 위해 함수를 가리키는 포인터를 사용해 왔다. 따라서 OO가 새롭게 만든 것은 전혀 없다.&lt;/p&gt;

&lt;p&gt;하지만 OO 언어는 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해준다.&lt;/p&gt;

&lt;p&gt;함수에 대한 포인터를 직접 사용하여 다형적 행위를 만드는 이 방식은 문제가 있는데, 함수 포인터가 위험하다는 사실이다. 만약 프로그래머가 특정 관례를 지키지 못한다면 버그가 발생하고, 이러한 버그는 찾아내고 없애기가 지독히 힘들다.&lt;/p&gt;

&lt;h2 id=&quot;다형성이-가진-힘&quot;&gt;다형성이 가진 힘&lt;/h2&gt;

&lt;p&gt;다형성이 가진 매력의 진가를 알아보기 위해 복사 프로그램 예제를 다시 살펴본다.&lt;/p&gt;

&lt;p&gt;새로운 입출력 장치가 생긴다면 프로그램에는 어떤 변화가 생기는가? 새로운 장비에서도 복사 프로그램이 동작하도록 만들려면 어떻게 수정해야 하는가?&lt;/p&gt;

&lt;p&gt;아무런 변경도 필요치 않다! 복사 프로그램 소스 코드는 입출력 드라이버의 소스 코드에 의존하지 않기 때문이다.&lt;/p&gt;

&lt;p&gt;다시 말해 입출력 드라이버가 복사 프로그램의 플러그인(plugin)이 된것이다.&lt;/p&gt;

&lt;h2 id=&quot;의존성-역전&quot;&gt;의존성 역전&lt;/h2&gt;

&lt;p&gt;다형성을 안전하고 편리하게 적용할 수 있는 메커니즘이 등장하기 전에는 main 함수가 고수준 함수를 호출하고, 고수준 함수는 다시 중간 수준 함수를 호출하며, 중간 함수는 다시 저수준 함수를 호출했다.&lt;/p&gt;

&lt;p&gt;이러한 호출 트리에서는 의존성의 방향이 반드시 제어흐름(flow of control)을 따르게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-01-PPPCleanArchitecture_ch5/2.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;소스 코드 의존성 vs. 제어 흐름&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어흐름에 따라 결정된다.&lt;/p&gt;

&lt;p&gt;하지만 다형성이 끼어들면 무언가 특별한 일이 일어난다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-01-PPPCleanArchitecture_ch5/3.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;의존성 역전&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ML1과 I 인터페이스 사이의 소스 코드 의존성(상속 관계)이 제어흐름과는 반대인 점을 주목해야 한다.&lt;/p&gt;

&lt;p&gt;이는 의존성 역전(dependency inversion)이라고 부르며, 소프트웨어 아키텍트 관점에서 이러한 현상은 심오한 의미를 갖는다.&lt;/p&gt;

&lt;p&gt;예를 들어 업무 규칙이 데이터베이스와 사용자 인터페이스(UI)에 의존하는 대신에, 시스템의 소스 코드 의존성을 반대로 배치하여 데이터베이스와 UI가 업무 규칙에 의존하게 만들 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/post/2022-05-01-PPPCleanArchitecture_ch5/4.jpg&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;데이터베이스와 사용자 인터페이스가 업무 규칙에 의존한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, UI와 데이터베이스가 업무 규칙의 플러그인이 된다는 뜻이다. 다시 말해 업무 규칙의 소스 코드에서는 UI나 데이터베이스를 호출하지 않는다.&lt;/p&gt;

&lt;p&gt;따라서 업무 규칙을 UI와 데이터베이스와 독립적으로 배포할 수 있다. UI나 데이터베이스에서 발생한 변경사항은 업무 규칙에 일절 영향을 미치지 않는다.&lt;/p&gt;

&lt;p&gt;즉, 이들 컴포넌트는 개별적이며 독립적으로 배포 가능하다.&lt;/p&gt;

&lt;p&gt;다시 말해 특정 컴포넌트의 소스코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다. 이것이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;배포 독립성(independent deployability)&lt;/code&gt;다.&lt;/p&gt;

&lt;p&gt;시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다. 그리고 이것이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;개발 독립성(independent developability)&lt;/code&gt;이다&lt;/p&gt;

</description>
        <pubDate>Mon, 02 May 2022 23:30:00 +0900</pubDate>
        <link>https://jandari91.github.io/posts/PPPCleanArchitecture_ch5/</link>
        <guid isPermaLink="true">https://jandari91.github.io/posts/PPPCleanArchitecture_ch5/</guid>
        
        <category>DDD</category>
        
        <category>CleanArchitecture</category>
        
        
        <category>DDD</category>
        
        <category>클린 아키텍처 소프트웨어 구조와 설계의 원칙</category>
        
        <category>2부 벽돌부터시작하기:프로그래밍 패러다임</category>
        
      </item>
    
  </channel>
</rss>
