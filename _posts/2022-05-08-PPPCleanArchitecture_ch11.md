---
title: 11장. DIP, 의존성 역전 원칙
author: Jandari
date: 2022-05-085 13:30:00 +09:00
categories: [DDD, 클린 아키텍처 소프트웨어 구조와 설계의 원칙, 3부 설계 원칙]
tags: [DDD, CleanArchitecture]
math: true
mermaid: true
---

# 소개

![image](/assets/img/post/2022-05-08-PPPCleanArchitecture_ch11/1.jpg)

클린아키텍처: 소프트웨어 구조와 설계의 원칙 책을 읽고 정리하며 소감을 적는 포스트입니다.

# DIP: 의존성 역전 원칙

의존성 역전 원칙에서 말하는 `'유연성이 극대화된 시스템'`이란 소스 코드 의존성이 추상(abstraction)에 의존하며 구체(concretion)에는 의존하지 않는 시스템이다.

자바 같은 정적 타입 언어에서는 이 말은 use, import, include 구분이 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 뜻이다. 구체적인 대상에는 절대로 의존해서는 안된다.

루비나 파이썬 같은 동적 타입에도 소스 코드 의존 관계에서 구체 모듈은 참조해서는 안된다.

하지만 String 같은 클래스는 구체 클래스이며, 이를 의존하지 않기는 어렵다.

반면 String 클래스는 변경되는 일은 거의 없으며, 있어도 엄격하게 통제된다.

이러한 이유로 DIP를 논할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다.

`우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰(volatile) 구체적인 요소이다.`

## 안정된 추상화

추상 인터페이스에 변경이 생기면 이를 구체화환 구현체들도 따라서 수정해야 한다. 반대로 구체적인 구현체에 변경이 생기더라도 그 구현체가 구현하는 인터페이스는 대다수의 경우 변경될 필요가 없다. 따라서 인터페이스는 구현체보다 변동성이 낮다.

즉, 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 안키텍처라는 뜻이다.

### 변동성이 큰 구체 클래스를 참조하지 말라.

대신 추상 인터페이스를 참조하라. 이 규칙은 객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리(Abstract Factory)를 사용하도록 강제한다.

### 변동성이 큰 구체 클래스로부터 파생하지 말라.

정적 타입 언어에서는 상속은 소스 코드에 존재하는 모든 관계 중에서 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다. 따라서 상속은 아주 신중하게 사용해야 한다.

### 구체 함수를 오버라이드 하지 말라.

대체로 구체 함수는 소스 코드 의존성을 필요로 한다. 따라서 구체 함수를 오버라이드 하면 이러한 의존성을 제거할 수 없게 되며, 실제로는 그 의존성을 상속하게 된다.

이러한 의존성을 제거하려면, 차라리 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.

### 구체적인 변동성이 크다면 절대로 그 이름을 언급하지 말라.

사실 이 실천법은 DIP 원칙을 다른 방식으로 풀어쓴 것이다.

## 팩토리

객체 지향 언어에서 바람직하지 못한 의존성을 처리할 때 추상 패토리를 사용하곤 한다.


![image](/assets/img/post/2022-05-08-PPPCleanArchitecture_ch11/2.jpg)
> 의존성을 관리하기 위해 추상 팩토리(Abstract Factory) 패턴을 사용한다.

위 그림에서 곡선은 아키텍처 경계를 뜻한다. 이 곡선은 구체적인 것들로부터 추상적인 것들을 분리한다. 소스 코드 의존성은 해당 곡선과 교차할 때 모두 한 방향, 즉 추상적인 쪽으로 향한다.

곡선은 시스템을 두 가지 컴포넌트로 분리한다. 하나는 추상 컴포넌트이며, 다른 하나는 구체 컴포넌트다. 추상 컴포넌트는 애플리케이션의 모든 고수준 업무 규칙을 포함한다.

제어흐름은 소스코드 의존성과는 정반대 방향으로 곡선을 가로지른다는 점에 주목한다. 다시 말해 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다.

이러한 이유로 이 원칙을 `의존성 역전(Dependency Inversion)`이라고 부른다.

## 구체 컴포넌트

이전 그림에서 구체 컴포넌트에는 구체적인 의존성(Service Factory Impl - ConcreteImpl)이 하나 있고, 따라서 DIP에 위반 된다.

이는 일반적이며 DIP 위배를 모두 없앨 수는 없다.

대다수의 시스템은 이러한 구체 컴포넌트를 최소한 하나는 포함할 것이다. 흔히 이 컴포넌트를 메인(Main)이라고 부르는데, main 함수를 포함하기 때문이다.

main 함수는 ServiceFactoryImpl의 인스턴스를 생성한 후, 이 인스턴스를 ServiceFactory 타입으로 전역 변수에 저장할 것이다. 그런 다음 Application은 이 전역 변수를 이용해서 ServiceFactoryImpl의 인스턴스에 접근할 것이다.

## 결론

그림에서 곡선은 이후의 장에서는 아키텍처 경계가 될 것이다. 그리고 의존성은 이 곡선을 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향한다. 추후 이 규칙은 의존성 규칙(Dependency Rule)이라 부를 것이다.


